<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>IRL: Idempotent Research Loop</title>
    <meta
      name="description"
      content="IRL is a document-centric workflow for reproducible AI-assisted research: you edit a plan, the AI executes, and git diffs become the audit trail."
    />

    <!-- Mermaid renderer (SVG). Requires internet to load. -->
    <script
      defer
      src="https://unpkg.com/beautiful-mermaid/dist/beautiful-mermaid.browser.global.js"
    ></script>

    <style>
      :root {
        --bg: #ffffff;
        --ink: #111827;
        --muted: #4b5563;
        --subtle: #6b7280;
        --border: #e5e7eb;
        --link: #2563eb;
        --code-bg: #0b1020;
        --code-ink: #e5e7eb;

        --sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background: var(--bg);
        color: var(--ink);
        font-family: var(--sans);
        line-height: 1.7;
        text-rendering: optimizeLegibility;
      }

      .wrap {
        max-width: 740px;
        margin: 0 auto;
        padding: 28px 18px 80px;
      }

      header {
        padding-bottom: 18px;
        border-bottom: 1px solid var(--border);
      }

      h1 {
        font-size: clamp(34px, 4.2vw, 48px);
        line-height: 1.1;
        letter-spacing: -0.02em;
        margin: 0 0 12px;
      }

      p {
        margin: 12px 0;
      }

      .lede {
        color: var(--muted);
        font-size: 17px;
        margin-top: 0;
      }

      a {
        color: var(--link);
        text-decoration: underline;
        text-underline-offset: 2px;
        text-decoration-thickness: 1px;
      }
      a:hover {
        text-decoration: none;
      }

      a:focus-visible,
      button:focus-visible {
        outline: 2px solid #111827;
        outline-offset: 2px;
      }

      .meta {
        font-family: var(--mono);
        font-size: 12px;
        color: var(--subtle);
        margin-top: 10px;
      }

      nav {
        margin-top: 18px;
        padding: 12px 14px;
        border: 1px solid var(--border);
        border-radius: 10px;
      }
      nav .title {
        font-family: var(--mono);
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--subtle);
        margin-bottom: 8px;
      }
      nav ul {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        grid-template-columns: 1fr;
        gap: 6px;
      }
      @media (min-width: 720px) {
        nav ul {
          grid-template-columns: 1fr 1fr;
        }
      }
      nav a {
        font-family: var(--mono);
        font-size: 12.5px;
      }

      main {
        margin-top: 22px;
      }

      section {
        padding-top: 22px;
        margin-top: 22px;
        border-top: 1px solid var(--border);
      }

      h2 {
        font-size: 24px;
        line-height: 1.25;
        letter-spacing: -0.01em;
        margin: 0 0 10px;
      }

      h3 {
        font-size: 18px;
        line-height: 1.3;
        margin: 18px 0 8px;
      }

      .subhead {
        color: var(--muted);
        margin: 0 0 10px;
      }

      .aside {
        border-left: 3px solid var(--border);
        padding-left: 14px;
        margin: 16px 0;
        color: var(--muted);
      }

      .figure {
        margin: 18px 0 6px;
      }

      .diagram {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 12px 12px;
        min-height: 180px;
        background: #ffffff;
      }
      .diagram svg {
        width: 100%;
        height: auto;
        min-height: 140px;
      }

      figcaption {
        margin: 10px auto 0;
        max-width: 78ch;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.55;
      }

      pre {
        margin: 14px 0;
        padding: 12px 12px;
        border-radius: 10px;
        background: var(--code-bg);
        color: var(--code-ink);
        overflow: auto;
        font-family: var(--mono);
        font-size: 12.5px;
        line-height: 1.55;
        border: 1px solid rgba(17, 24, 39, 0.25);
      }

      code {
        font-family: var(--mono);
      }

      .inline-code {
        background: #f3f4f6;
        padding: 0.1rem 0.25rem;
        border-radius: 6px;
        border: 1px solid var(--border);
        font-size: 0.92em;
      }

      .toy {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 12px 12px;
        background: #ffffff;
      }
      .toy button {
        font-family: var(--mono);
        font-size: 12px;
        padding: 8px 10px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: #ffffff;
        cursor: pointer;
      }
      .toy button:hover {
        background: #f9fafb;
      }
      .toy button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }
      .toy ol {
        margin: 12px 0 0;
        padding-left: 18px;
      }
      .toy li {
        margin: 6px 0;
      }
      .toy li.active {
        background: #f9fafb;
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 6px 8px;
        margin-left: -10px;
        margin-right: -2px;
      }

      footer {
        margin-top: 28px;
        padding-top: 18px;
        border-top: 1px solid var(--border);
        color: var(--subtle);
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <h1>IRL: Idempotent Research Loop</h1>
        <p class="lede">
          I'm obsessed with a specific kind of failure: you do something smart
          with an AI assistant, it works, you feel productive... and then the
          whole thing evaporates into a chat transcript nobody will ever read
          again.
        </p>
        <p class="lede">
          A week later you can't answer basic questions. What inputs did we use?
          What assumptions did we make? Which files changed? If the result is
          wrong, where did it go wrong? And if you rerun it, do you get the same
          thing or a slightly different thing that looks right until it doesn't?
        </p>
        <p class="lede">
          IRL is the pattern I wish I had earlier: write your intent in a plan
          file, let an assistant execute it, and let git diffs be the audit
          trail. It's not a product. It's a discipline that turns "AI did stuff"
          into artifacts you can inspect.
        </p>
        <p class="meta">
          Artifact: <span class="inline-code">03-outputs/irl-explainer-site/index.html</span>
        </p>

        <nav aria-label="Table of contents">
          <div class="title">Contents</div>
          <ul>
            <li><a href="#what">What IRL Is</a></li>
            <li><a href="#loop">The Core Loop</a></li>
            <li><a href="#anatomy">Project Anatomy</a></li>
            <li><a href="#sequence">A Single Run (Sequence)</a></li>
            <li><a href="#idempotency">Idempotency (The Boring Part)</a></li>
            <li><a href="#review">Review, Commit, Repeat</a></li>
            <li><a href="#remote">Remote Testing (ZeroTier)</a></li>
          </ul>
        </nav>
      </header>

      <main>
        <section id="what">
          <h2>What IRL Is</h2>
          <p class="subhead">
            An IRL project is a filesystem contract and a discipline: the plan
            owns intent, artifacts hold evidence, and diffs tell you what changed.
          </p>

          <p>
            The first move is small but important: instead of keeping “what we’re
            trying to do” in a chat thread, you keep it in a file. That file is
            your control surface. It’s where you state objectives, inputs, outputs,
            constraints, and what “done” means. When something needs to change,
            you edit the plan, not your assistant’s memory.
          </p>

          <p>
            The second move is equally boring: the assistant produces artifacts,
            not vibes. If a step matters, it should land as something you can
            inspect: an HTML report, a CSV, a diagram, a script, a test. Then you
            can review it like you would any other engineering output.
          </p>

          <p>
            The mental model I keep coming back to is a Makefile for thinking.
            The plan is declarative: "given these inputs, produce these outputs,
            under these constraints." The assistant is an executor, not an
            author of intent. If you want different behavior, you change the
            plan and rerun.
          </p>

          <p>
            There is a trade-off: you spend more time up front writing down what
            you mean. But you get the thing most AI workflows lack by default:
            the ability to point at a commit and say, "this is what we did, this
            is what changed, and this is why."
          </p>

          <p class="aside">
            IRL isn’t “the AI remembers forever.” It’s “assume it won’t, then
            write down what matters in versioned files.” If it can’t be diffed,
            it’s hard to trust.
          </p>

          <h3>A Useful Template For Plan Steps</h3>
          <pre><code>## Task: [short name]

- Inputs: [files, links, assumptions]
- Outputs: [exact paths]
- Constraints: [idempotency rules]
- Done when: [verifiable checks]</code></pre>
        </section>

        <section id="loop">
          <h2>The Core Loop</h2>
          <p class="subhead">
            This loop is intentionally repetitive. Repetition is how you keep
            the work inspectable.
          </p>

          <p>
            The loop has six verbs: edit, execute, write, review, commit,
            repeat. If any one of those verbs is missing, the whole thing tends
            to collapse back into "chat with an AI until it feels done."
          </p>

          <p>
            Notice what isn't in the loop: "remember." IRL assumes memory is
            unreliable. Your plan file replaces memory as the source of truth,
            and your outputs replace "trust me" explanations as evidence.
          </p>

          <p>
            A practical rule of thumb: keep execution short enough that you can
            rerun it without dread. If a run takes 30 seconds to a few minutes,
            you're more likely to iterate. If it takes half an hour, you'll
            avoid reruns, and that’s where mistakes hide.
          </p>

          <figure class="figure">
            <div
              id="diagram-loop"
              class="diagram"
              role="img"
              aria-label="Flowchart showing the IRL loop from plan edits to execution to outputs to git diffs and commits"
            ></div>
            <figcaption>
              <strong>Fig 1.</strong> The IRL loop. You edit the plan (a document),
              run the assistant, produce artifacts in stable locations, review the
              diffs, then commit what you intended. The final commit becomes a
              durable checkpoint you can return to, reproduce, or revert.
            </figcaption>
          </figure>

          <div class="toy" aria-label="Interactive toy: animate the loop">
            <button id="toy-run" type="button">Run The Loop (Toy)</button>
            <ol id="toy-steps">
              <li>Edit <span class="inline-code">main-plan.md</span> (intent)</li>
              <li>Execute steps (automation)</li>
              <li>Write artifacts (evidence)</li>
              <li>Review diffs (audit)</li>
              <li>Commit (checkpoint)</li>
              <li>Repeat (iterate)</li>
            </ol>
            <p class="aside" style="margin-bottom: 0">
              This is the whole philosophy in miniature: intent, evidence, audit,
              checkpoint.
            </p>
          </div>
        </section>

        <section id="anatomy">
          <h2>Project Anatomy</h2>
          <p class="subhead">
            A project layout doesn’t guarantee good work, but it makes good work
            easier to recognize.
          </p>

          <p>
            If you’ve ever inherited a research folder full of files named
            <span class="inline-code">final_v7_REAL_FINAL2.xlsx</span>, you already
            understand why a simple contract helps. IRL prefers separation:
            inputs and derived data should not mix. Outputs should be artifacts,
            not scratch pads. Logs should exist so you can see what ran.
          </p>

          <p>
            The raw/derived split is doing real work. Raw data is sacred: it
            should be immutable, or at least treated as immutable. Derived data
            is disposable: if it gets corrupted, you should be able to delete it
            and regenerate it from raw inputs by rerunning the plan.
          </p>

          <p>
            Outputs are a different category. They’re the things you want to
            show someone else: a report, a figure, a table, a website artifact.
            Outputs should have stable filenames so diffs stay meaningful
            (<span class="inline-code">03-outputs/report.html</span>, not
            <span class="inline-code">report_2026-02-08_1412.html</span> unless
            you explicitly want versioned snapshots).
          </p>

          <p class="aside">
            Big binaries are an edge case. If your data is too large for git,
            you can still keep the contract: store raw data elsewhere, commit a
            manifest (paths, checksums, versions), and make regeneration steps
            explicit.
          </p>

          <figure class="figure">
            <div
              id="diagram-anatomy"
              class="diagram"
              role="img"
              aria-label="Flowchart showing an IRL project folder structure and what each folder is for"
            ></div>
            <figcaption>
              <strong>Fig 2.</strong> A typical IRL project layout. The plan is the
              control surface. Raw and derived data are separated to avoid silent
              contamination. Outputs contain reviewable artifacts (reports, figures,
              tables). Logs capture what executed and when.
            </figcaption>
          </figure>

          <pre><code>my-project/
├── main-plan.md
├── 02-data/
│   ├── raw/
│   └── derived/
├── 03-outputs/
└── 04-logs/</code></pre>
        </section>

        <section id="sequence">
          <h2>A Single Run (Sequence)</h2>
          <p class="subhead">
            The loop looks simple in a flowchart. Here’s what a single run feels
            like when you’re actually doing it.
          </p>

          <p>
            When you execute an IRL step, you want a predictable interaction:
            the plan points to inputs, the assistant reads those inputs, it writes
            outputs to specific paths, and it does not quietly mutate unrelated
            files. If a step needs to update state, it should do it explicitly
            and in the open, so git can show you.
          </p>

          <p>
            The question I ask after every run is simple: could someone else
            reproduce this result from scratch? Not "could they guess what I
            meant," but could they follow the files. If the answer is no, the
            fix is usually mechanical: missing inputs, unclear output paths, or
            hidden decisions that should be written down.
          </p>

          <p>
            A nice side effect is that the assistant becomes easier to manage.
            When the plan says, "write <span class="inline-code">summary.csv</span>
            and <span class="inline-code">report.html</span>," you can review
            exactly those artifacts. When it doesn’t, you end up spelunking
            through unrelated files trying to learn what happened.
          </p>

          <figure class="figure">
            <div
              id="diagram-sequence"
              class="diagram"
              role="img"
              aria-label="Sequence diagram of a single IRL run: user edits plan, agent reads plan and inputs, writes outputs, user reviews diffs and commits"
            ></div>
            <figcaption>
              <strong>Fig 3.</strong> A single IRL run. The plan file drives what
              gets read and written. Outputs land in stable locations. Review
              happens through diffs (what changed, exactly), and commits become
              checkpoints you can reproduce.
            </figcaption>
          </figure>

          <h3>What “Good” Feels Like</h3>
          <p>
            A good run is boring: it changes the files you expected, produces the
            artifacts you asked for, and leaves everything else untouched. The
            boring part is the point. Once runs are boring, collaboration becomes
            easier: teammates can trust the structure, review diffs, and rerun
            steps without fear.
          </p>
        </section>

        <section id="idempotency">
          <h2>Idempotency (The Boring Part)</h2>
          <p class="subhead">
            The fastest way to lose trust is to rerun a step and get mystery
            changes. Idempotency is how you avoid that.
          </p>

          <p>
            In practice, “idempotent” means: if you execute the same step twice,
            the second run should either do nothing or produce identical outputs.
            That requires a few habits: stable filenames, explicit output paths,
            and checks before overwriting. It also means avoiding “append forever”
            logs in places where you want clean diffs.
          </p>

          <p>
            The easiest way to accidentally break idempotency is to hide time in
            your outputs. Timestamps in filenames feel harmless until your repo
            fills up with near-duplicates and you can’t tell which one matters.
            IRL prefers stable paths for "current truth" and explicit snapshots
            only when you mean to snapshot.
          </p>

          <p>
            Another common failure mode is nondeterminism. If a step depends on
            "latest" anything, you usually want to pin it: a commit hash, a
            version number, or a downloaded artifact with a checksum. Otherwise,
            reruns become "it worked yesterday" stories.
          </p>

          <figure class="figure">
            <div
              id="diagram-idempotency"
              class="diagram"
              role="img"
              aria-label="Flowchart showing an idempotent step: check for existing outputs, validate, reuse or regenerate deterministically"
            ></div>
            <figcaption>
              <strong>Fig 4.</strong> An idempotent step. Before doing expensive
              work, check whether the expected outputs already exist. If they do,
              validate and reuse them. If they’re missing or invalid, regenerate
              deterministically and write to the same stable path.
            </figcaption>
          </figure>

          <p class="aside">
            If you can’t make a step perfectly idempotent, the fallback is
            explicit versioning: write to a timestamped path and record the link
            in the plan, so reruns are still legible.
          </p>
        </section>

        <section id="review">
          <h2>Review, Commit, Repeat</h2>
          <p class="subhead">
            The loop only works if “review” is real. Diffs are where reality
            lives.
          </p>

          <p>
            A commit in IRL isn’t just “save progress.” It’s a checkpoint with a
            reason. After execution, you review what changed and decide whether it
            matches the plan’s intent. If you can’t explain a change, it doesn’t
            get committed.
          </p>

          <p>
            Review is not one big thing; it’s a few small questions. Did we touch
            the right files? Did we accidentally modify something unrelated? Are
            there new outputs that should be kept out of git (large binaries,
            caches)? And most importantly: does the change actually support the
            plan’s goal, or did we just produce activity?
          </p>

          <p>
            This is where git earns its keep. If a step is truly idempotent, a
            second run should result in an empty diff. That’s an incredibly strong
            signal: it means you can rerun without fear, and it means reviewers
            can focus on intent rather than forensic reconstruction.
          </p>

          <figure class="figure">
            <div
              id="diagram-state"
              class="diagram"
              role="img"
              aria-label="State diagram for an IRL iteration: draft plan, execute, review diffs, commit or revise plan, repeat"
            ></div>
            <figcaption>
              <strong>Fig 5.</strong> The iteration state machine. Most of the work
              is “draft plan” and “review diffs.” Execution is a short, bounded
              phase. If review fails, you revise the plan and rerun. If it passes,
              you commit and move on.
            </figcaption>
          </figure>

          <h3>A Minimal Review Checklist</h3>
          <pre><code># before execution
git status --porcelain

# after execution
git diff
git diff --stat

# only then
git add -A
git commit -m "..."</code></pre>
        </section>

        <section id="remote">
          <h2>Remote Testing (ZeroTier)</h2>
          <p class="subhead">
            Sometimes you want to check the artifact from another machine (or
            show it to a reviewer) without deploying anything.
          </p>

          <p>
            This explainer site is a static artifact. You can serve it locally and
            access it over a shared network (LAN or ZeroTier) by pointing a browser
            at your machine’s IP and port.
          </p>

          <p>
            If you’re testing from your phone on the same WiFi, the pattern is:
            start the server, find your machine’s LAN IP (often
            <span class="inline-code">192.168.x.y</span>), then open
            <span class="inline-code">http://&lt;ip&gt;:8765/</span>.
          </p>

          <p class="aside">
            Security note: <span class="inline-code">python3 -m http.server</span>
            is a tiny dev server, not a hardened web server. Use it on trusted
            networks (or a private ZeroTier network), and avoid serving directories
            containing secrets.
          </p>

          <pre><code># from this repo
make -C 03-outputs/irl-explainer-site serve PORT=8765

# find likely IPs
make -C 03-outputs/irl-explainer-site ips

# if you use ZeroTier
make -C 03-outputs/irl-explainer-site zt</code></pre>
        </section>
      </main>

      <footer>
        Diagrams render client-side via <span class="inline-code">beautiful-mermaid</span>.
        If the CDN is blocked, diagram containers will remain empty.
      </footer>
    </div>

    <script>
      (function () {
        const theme = {
          bg: "#ffffff",
          fg: "#111827",
          accent: "#111827",
          muted: "#6b7280",
          surface: "#ffffff",
          border: "#e5e7eb",
        };

        const diagrams = {
          loop:
            "flowchart LR\n" +
            "  A>main-plan.md] --> B[Execute steps]\n" +
            "  B --> C[(02-data)]\n" +
            "  B --> D[(03-outputs)]\n" +
            "  C --> E[Review diffs]\n" +
            "  D --> E\n" +
            "  E --> F([Commit])\n" +
            "  F --> A\n",
          anatomy:
            "flowchart TB\n" +
            "  subgraph P[IRL project]\n" +
            "    PLAN>main-plan.md]\n" +
            "    D2[(02-data)]\n" +
            "    O3[(03-outputs)]\n" +
            "    L4[(04-logs)]\n" +
            "  end\n" +
            "  PLAN --> D2\n" +
            "  PLAN --> O3\n" +
            "  PLAN --> L4\n",
          sequence:
            "sequenceDiagram\n" +
            "  participant U as User\n" +
            "  participant P as Plan (main-plan.md)\n" +
            "  participant A as Assistant\n" +
            "  participant FS as Filesystem\n" +
            "  participant G as Git\n" +
            "  U->>P: Edit intent + constraints\n" +
            "  U->>A: Execute the plan\n" +
            "  A->>P: Read instructions\n" +
            "  A->>FS: Read inputs\n" +
            "  A->>FS: Write outputs + logs\n" +
            "  U->>G: Review diffs\n" +
            "  U->>G: Commit checkpoint\n",
          idempotency:
            "flowchart TB\n" +
            "  S([Start step]) --> O{Outputs exist?}\n" +
            "  O -- Yes --> V{Validate outputs}\n" +
            "  V -- OK --> R[Reuse outputs]\n" +
            "  V -- Bad --> G[Regenerate]\n" +
            "  O -- No --> G\n" +
            "  G --> W[Write to stable paths]\n" +
            "  W --> E([End])\n" +
            "  R --> E\n",
          state:
            "stateDiagram-v2\n" +
            "  [*] --> DraftPlan\n" +
            "  DraftPlan --> Execute: run assistant\n" +
            "  Execute --> ReviewDiffs\n" +
            "  ReviewDiffs --> Commit: changes match intent\n" +
            "  ReviewDiffs --> DraftPlan: revise plan\n" +
            "  Commit --> DraftPlan: next iteration\n",
        };

        async function render(id, code) {
          const el = document.getElementById(id);
          if (!el) return;
          try {
            el.innerHTML = await window.beautifulMermaid.renderMermaid(code, theme);
          } catch (e) {
            el.innerHTML =
              '<pre style="white-space:pre-wrap;background:#fff;border:1px solid #e5e7eb;border-radius:10px;padding:12px;color:#991b1b;">' +
              "Diagram failed to render. Mermaid source:\\n\\n" +
              code.replace(/</g, "&lt;") +
              "</pre>";
          }
        }

        function renderWhenReady() {
          if (!window.beautifulMermaid) return false;
          render("diagram-loop", diagrams.loop);
          render("diagram-anatomy", diagrams.anatomy);
          render("diagram-sequence", diagrams.sequence);
          render("diagram-idempotency", diagrams.idempotency);
          render("diagram-state", diagrams.state);
          return true;
        }

        let tries = 0;
        const timer = setInterval(function () {
          tries++;
          if (renderWhenReady() || tries > 80) clearInterval(timer);
        }, 100);

        // Simple interactive toy: highlight steps in order.
        const btn = document.getElementById("toy-run");
        const steps = Array.from(document.querySelectorAll("#toy-steps li"));
        if (btn && steps.length) {
          btn.addEventListener("click", async function () {
            btn.disabled = true;
            for (let i = 0; i < steps.length; i++) {
              steps.forEach((x) => x.classList.remove("active"));
              steps[i].classList.add("active");
              await new Promise((r) => setTimeout(r, 550));
            }
            await new Promise((r) => setTimeout(r, 350));
            steps.forEach((x) => x.classList.remove("active"));
            btn.disabled = false;
          });
        }
      })();
    </script>
  </body>
</html>
