<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Toy Playground — IRL</title>

    <style>
      :root {
        --ink: #111827;
        --muted: #4b5563;
        --subtle: #6b7280;
        --border: #e5e7eb;
        --teal: #0d9488;
        --teal-light: #ccfbf1;
        --amber: #d97706;
        --amber-light: #fef3c7;

        --sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }

      body {
        margin: 0;
        background: linear-gradient(180deg, #fff 0%, #f9fafb 50%, #fff 100%);
        color: var(--ink);
        font-family: var(--sans);
        line-height: 1.7;
        text-rendering: optimizeLegibility;
      }

      .topbar {
        position: sticky; top: 0; z-index: 50;
        background: rgba(255,255,255,0.82);
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--border);
      }
      .topbar-inner {
        max-width: 860px; margin: 0 auto; padding: 12px 18px;
        display: flex; align-items: center; justify-content: space-between; gap: 12px;
      }
      .brand {
        display: inline-flex; align-items: center; gap: 10px;
        font-weight: 650; color: var(--ink); text-decoration: none; letter-spacing: -0.01em;
      }
      .brand svg { width: 14px; height: 14px; display: block; }
      .topbar a.util {
        font-family: var(--mono); font-size: 12px; color: var(--subtle); text-decoration: none;
      }
      .topbar a.util:hover { color: var(--ink); }

      .wrap { max-width: 860px; margin: 0 auto; padding: 28px 18px 80px; }

      .page-header {
        padding: 30px 0 24px; border-bottom: 1px solid var(--border); text-align: center;
      }
      h1 {
        font-size: clamp(28px, 3.5vw, 40px); line-height: 1.1;
        letter-spacing: -0.02em; margin: 0 0 8px;
      }
      .page-subtitle { font-family: var(--mono); font-size: 13px; color: var(--subtle); }

      p { margin: 12px 0; }

      h2 {
        font-size: 22px; line-height: 1.25; letter-spacing: -0.01em;
        margin: 32px 0 6px; padding-bottom: 6px; border-bottom: 1px solid var(--border);
      }
      .intro {
        color: var(--muted); font-size: 16px;
        max-width: 580px; margin: 10px auto 20px; text-align: center;
      }

      .contrast { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
      @media (max-width: 600px) { .contrast { grid-template-columns: 1fr; } }

      .panel {
        border: 1px solid var(--border); border-radius: 12px;
        background: #fff; overflow: hidden;
      }
      .panel-head {
        padding: 12px 14px 8px;
        display: flex; align-items: center; justify-content: space-between;
      }
      .panel-label {
        font-family: var(--mono); font-size: 11px; font-weight: 600;
        letter-spacing: 0.08em; text-transform: uppercase;
      }
      .panel-label.teal { color: var(--teal); }
      .panel-label.amber { color: var(--amber); }

      .run-btn {
        font-family: var(--mono); font-size: 11px; padding: 4px 10px;
        border-radius: 6px; border: 1px solid var(--border);
        background: #fff; cursor: pointer; transition: background 0.15s;
      }
      .run-btn:hover { background: #f9fafb; }
      .run-btn:disabled { cursor: not-allowed; opacity: 0.4; }

      .canvas-wrap {
        position: relative; width: 100%; aspect-ratio: 5 / 3;
        background: #fafafa; border-top: 1px solid var(--border);
      }
      .canvas-wrap canvas {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      }

      .panel-foot {
        padding: 8px 14px; font-family: var(--mono); font-size: 11px;
        line-height: 1.4; border-top: 1px solid var(--border);
        min-height: 34px; transition: background 0.4s, color 0.4s;
      }
      .panel-foot.neutral { background: #f9fafb; color: var(--subtle); }
      .panel-foot.teal { background: var(--teal-light); color: var(--teal); }
      .panel-foot.amber { background: var(--amber-light); color: var(--amber); }

      .aside {
        border-left: 3px solid var(--border); padding-left: 14px;
        margin: 22px 0; color: var(--muted); font-size: 15px;
      }

      footer {
        margin-top: 28px; padding-top: 18px;
        border-top: 1px solid var(--border); color: var(--subtle); font-size: 13px;
      }
      a {
        color: var(--ink); text-decoration: underline;
        text-underline-offset: 2px; text-decoration-thickness: 1px;
      }
      a:hover { text-decoration: none; }
      a:focus-visible, button:focus-visible { outline: 2px solid var(--ink); outline-offset: 2px; }
    </style>
  </head>
  <body>
    <header class="topbar">
      <div class="topbar-inner">
        <a class="brand" href="index.html" aria-label="Back to explainer">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <circle cx="8" cy="8" r="6" fill="none" stroke="currentColor" stroke-width="1.5"></circle>
            <circle cx="8" cy="8" r="2" fill="currentColor"></circle>
          </svg>
          IRL Toys
        </a>
        <a class="util" href="index.html">Back to Explainer</a>
      </div>
    </header>

    <div class="wrap">
      <div class="page-header">
        <h1>Toy Playground</h1>
        <div class="page-subtitle">Design experiments for IRL concepts</div>
      </div>

      <h2>Idempotent vs. Non-Idempotent</h2>
      <p class="intro">
        Press Run on each side. One constellation always forms the same shape.
        The other never does.
      </p>

      <div class="contrast">
        <div class="panel">
          <div class="panel-head">
            <span class="panel-label teal">Idempotent</span>
            <button class="run-btn" id="idem-btn" type="button">Run</button>
          </div>
          <div class="canvas-wrap"><canvas id="cv-idem"></canvas></div>
          <div class="panel-foot neutral" id="ft-idem">Same recipe, same dish. Press Run.</div>
        </div>
        <div class="panel">
          <div class="panel-head">
            <span class="panel-label amber">Non-Idempotent</span>
            <button class="run-btn" id="nonidem-btn" type="button">Run</button>
          </div>
          <div class="canvas-wrap"><canvas id="cv-nonidem"></canvas></div>
          <div class="panel-foot neutral" id="ft-nonidem">Same recipe, different dish. Press Run.</div>
        </div>
      </div>

      <p class="aside">
        The teal side is safe to rerun: the constellation always settles into
        the same shape. The amber side drifts: positions shift, new dots appear,
        and you can't tell which run was "right." Idempotency is what makes
        iteration trustworthy.
      </p>

      <h2>The Recipe</h2>
      <p class="intro">
        You write a plan. The AI follows it and produces files you can inspect.
        Each cycle layers more work onto a stable foundation.
      </p>

      <div class="panel" style="max-width:100%">
        <div class="panel-head">
          <span class="panel-label" style="color:var(--subtle)">Plan &rarr; Process &rarr; Artifacts</span>
          <button class="run-btn" id="recipe-btn" type="button">Run Cycle</button>
        </div>
        <div class="canvas-wrap" style="aspect-ratio:3/1"><canvas id="cv-recipe"></canvas></div>
        <div class="panel-foot neutral" id="ft-recipe">Press Run Cycle to watch the flow.</div>
      </div>

      <p class="aside">
        The plan stays put. Each cycle sends instructions through the AI, which
        produces artifacts that accumulate on the right. You start small, layer
        complexity, and every output is something you can inspect and build on.
      </p>

      <footer><a href="index.html">Back to the explainer</a></footer>
    </div>

    <script>
    (function () {
      var N = 12;
      var R = 5;
      var LINE_DIST = 80;
      var SCATTER_MS = 300;
      var SETTLE_MS = 800;

      function ease(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }

      /* ── Canvas boilerplate ── */
      function init(id) {
        var c = document.getElementById(id);
        var dpr = window.devicePixelRatio || 1;
        function fit() {
          var r = c.parentElement.getBoundingClientRect();
          c.width = r.width * dpr; c.height = r.height * dpr;
        }
        fit(); window.addEventListener("resize", fit);
        return { c: c, dpr: dpr, fit: fit };
      }
      function ctx(cv) {
        var g = cv.c.getContext("2d");
        g.setTransform(cv.dpr, 0, 0, cv.dpr, 0, 0);
        return g;
      }
      function dim(cv) { return { w: cv.c.width / cv.dpr, h: cv.c.height / cv.dpr }; }

      /* ── Seeded RNG (mulberry32) ── */
      function rng(s) {
        return function () {
          s |= 0; s = s + 0x6d2b79f5 | 0;
          var t = Math.imul(s ^ s >>> 15, 1 | s);
          t = (t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t;
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
      }

      function seededPts(n, w, h, seed) {
        var r = rng(seed), pad = R + 14, pts = [];
        for (var i = 0; i < n; i++)
          pts.push({ x: pad + r() * (w - 2*pad), y: pad + r() * (h - 2*pad) });
        return pts;
      }
      function randPts(n, w, h) {
        var pad = R + 14, pts = [];
        for (var i = 0; i < n; i++)
          pts.push({ x: pad + Math.random()*(w-2*pad), y: pad + Math.random()*(h-2*pad) });
        return pts;
      }

      /* ── Drawing ── */
      function draw(g, pts, colors, w, h, lineColor) {
        g.clearRect(0, 0, w, h);

        /* constellation lines */
        g.strokeStyle = lineColor;
        g.lineWidth = 1;
        for (var i = 0; i < pts.length; i++) {
          for (var j = i + 1; j < pts.length; j++) {
            var dx = pts[i].x - pts[j].x, dy = pts[i].y - pts[j].y;
            var d = Math.sqrt(dx*dx + dy*dy);
            if (d < LINE_DIST) {
              var a = 0.25 * (1 - d / LINE_DIST);
              g.globalAlpha = a;
              g.beginPath();
              g.moveTo(pts[i].x, pts[i].y);
              g.lineTo(pts[j].x, pts[j].y);
              g.stroke();
            }
          }
        }

        /* dots */
        for (var k = 0; k < pts.length; k++) {
          g.globalAlpha = pts[k].a !== undefined ? pts[k].a : 1;
          g.beginPath();
          g.arc(pts[k].x, pts[k].y, R, 0, Math.PI * 2);
          g.fillStyle = colors[k % colors.length];
          g.fill();
        }
        g.globalAlpha = 1;
      }

      /* ── Two-phase animation: scatter out, then settle ── */
      function animate(cv, from, to, colors, lineColor, done) {
        var d = dim(cv);
        /* Phase 1: scatter from current positions outward */
        var scattered = [];
        var cx = d.w / 2, cy = d.h / 2;
        for (var i = 0; i < to.length; i++) {
          var src = from[i] || { x: cx, y: cy };
          var angle = Math.atan2(src.y - cy, src.x - cx) + (Math.random()-0.5)*1.2;
          var dist = 30 + Math.random() * 40;
          scattered.push({
            x: src.x + Math.cos(angle) * dist,
            y: src.y + Math.sin(angle) * dist,
          });
        }

        var start = null;
        var totalMs = SCATTER_MS + SETTLE_MS;

        function frame(ts) {
          if (!start) start = ts;
          var el = ts - start;
          var g = ctx(cv);
          var pts = [];

          if (el < SCATTER_MS) {
            /* Phase 1: current → scattered */
            var t1 = ease(el / SCATTER_MS);
            for (var i = 0; i < to.length; i++) {
              var src = from[i] || { x: cx, y: cy };
              pts.push({
                x: src.x + (scattered[i].x - src.x) * t1,
                y: src.y + (scattered[i].y - src.y) * t1,
                a: from[i] ? 1 : t1,
              });
            }
          } else {
            /* Phase 2: scattered → target */
            var t2 = ease(Math.min((el - SCATTER_MS) / SETTLE_MS, 1));
            for (var j = 0; j < to.length; j++) {
              pts.push({
                x: scattered[j].x + (to[j].x - scattered[j].x) * t2,
                y: scattered[j].y + (to[j].y - scattered[j].y) * t2,
                a: from[j] ? 1 : Math.min(1, (el / SCATTER_MS)),
              });
            }
          }

          draw(g, pts, colors, d.w, d.h, lineColor);

          if (el < totalMs) {
            requestAnimationFrame(frame);
          } else {
            /* final clean draw at exact targets */
            draw(g, to.map(function(p) { return { x:p.x, y:p.y, a:1 }; }), colors, d.w, d.h, lineColor);
            if (done) done(to);
          }
        }
        requestAnimationFrame(frame);
      }

      /* ── Color palettes ── */
      var tealPalette = ["#0d9488","#14b8a6","#2dd4bf","#5eead4","#99f6e4","#0f766e"];
      var amberPalette = ["#d97706","#f59e0b","#fbbf24","#fcd34d","#b45309","#92400e"];

      function pickColors(n, palette, seed) {
        var r = rng(seed), out = [];
        for (var i = 0; i < n; i++) out.push(palette[Math.floor(r() * palette.length)]);
        return out;
      }

      /* ══════════════════════════════════════
         IDEMPOTENT
         ══════════════════════════════════════ */
      var iCv = init("cv-idem");
      var iBtn = document.getElementById("idem-btn");
      var iFt = document.getElementById("ft-idem");
      var iRuns = 0, iCur = null;
      var SEED = 42;
      var iCol = pickColors(N, tealPalette, SEED);

      (function () {
        var d = dim(iCv);
        iCur = randPts(N, d.w, d.h);
        draw(ctx(iCv), iCur, iCol, d.w, d.h, "rgba(13,148,136,0.35)");
      })();

      iBtn.addEventListener("click", function () {
        iBtn.disabled = true;
        iRuns++;
        var d = dim(iCv);
        var targets = seededPts(N, d.w, d.h, SEED);
        animate(iCv, iCur, targets, iCol, "rgba(13,148,136,0.35)", function (final) {
          iCur = final;
          iBtn.disabled = false;
          iFt.className = "panel-foot teal";
          iFt.textContent = iRuns === 1
            ? "Run #1 \u2014 constellation formed."
            : "Run #" + iRuns + " \u2014 identical shape. Nothing changed.";
        });
      });

      /* ══════════════════════════════════════
         NON-IDEMPOTENT
         ══════════════════════════════════════ */
      var nCv = init("cv-nonidem");
      var nBtn = document.getElementById("nonidem-btn");
      var nFt = document.getElementById("ft-nonidem");
      var nRuns = 0, nCur = null, nCount = N;
      var nCol = pickColors(N + 30, amberPalette, 99);

      (function () {
        var d = dim(nCv);
        nCur = randPts(N, d.w, d.h);
        draw(ctx(nCv), nCur, nCol, d.w, d.h, "rgba(217,119,6,0.3)");
      })();

      nBtn.addEventListener("click", function () {
        nBtn.disabled = true;
        nRuns++;
        var d = dim(nCv);
        var extra = Math.floor(Math.random() * 2) + 1;
        var newN = nCount + extra;
        var targets = randPts(newN, d.w, d.h);

        /* Pad from with center-spawns for new dots */
        var from = (nCur || []).slice();
        while (from.length < newN) from.push({ x: d.w/2, y: d.h/2 });

        animate(nCv, from, targets, nCol, "rgba(217,119,6,0.3)", function (final) {
          nCur = final;
          nCount = newN;
          nBtn.disabled = false;
          nFt.className = "panel-foot amber";
          nFt.textContent = nRuns === 1
            ? "Run #1 \u2014 " + newN + " dots, random positions."
            : "Run #" + nRuns + " \u2014 " + newN + " dots. Shape changed again.";
        });
      });
    })();

    /* ══════════════════════════════════════════════
       TOY 2: THE RECIPE — plan → process → artifacts
       ══════════════════════════════════════════════ */
    (function () {
      var cv = (function (id) {
        var c = document.getElementById(id);
        var dpr = window.devicePixelRatio || 1;
        function fit() {
          var r = c.parentElement.getBoundingClientRect();
          c.width = r.width * dpr; c.height = r.height * dpr;
        }
        fit(); window.addEventListener("resize", fit);
        return { c: c, dpr: dpr };
      })("cv-recipe");

      var btn = document.getElementById("recipe-btn");
      var ft = document.getElementById("ft-recipe");
      var cycles = 0;
      var artifacts = []; /* settled file rectangles on the right */

      function g() {
        var ctx = cv.c.getContext("2d");
        ctx.setTransform(cv.dpr, 0, 0, cv.dpr, 0, 0);
        return ctx;
      }
      function W() { return cv.c.width / cv.dpr; }
      function H() { return cv.c.height / cv.dpr; }

      var PLAN_COLOR = "#0d9488";
      var PROCESS_COLOR = "#6b7280";
      var ARTIFACT_COLORS = ["#0d9488","#14b8a6","#2dd4bf","#0f766e","#5eead4"];
      var PARTICLE_COUNT = 5;
      var FLOW_MS = 1600;

      function ease(t) { return t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2; }

      /* Draw the static scene: plan box, process zone, settled artifacts */
      function drawScene(ctx) {
        var w = W(), h = H();
        ctx.clearRect(0, 0, w, h);

        var planX = w * 0.08, planY = h * 0.25, planW = w * 0.12, planH = h * 0.5;
        var procX = w * 0.38, procY = h * 0.3, procR = h * 0.2;

        /* Plan box */
        ctx.fillStyle = PLAN_COLOR;
        ctx.globalAlpha = 0.12;
        ctx.beginPath();
        roundRect(ctx, planX, planY, planW, planH, 6);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.strokeStyle = PLAN_COLOR;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        roundRect(ctx, planX, planY, planW, planH, 6);
        ctx.stroke();

        /* Plan label */
        ctx.fillStyle = PLAN_COLOR;
        ctx.font = "600 10px " + getComputedStyle(document.body).getPropertyValue("--mono");
        ctx.textAlign = "center";
        ctx.fillText("PLAN", planX + planW/2, planY + planH/2 + 4);

        /* Plan lines (representing text) */
        ctx.strokeStyle = PLAN_COLOR;
        ctx.globalAlpha = 0.3;
        ctx.lineWidth = 1;
        for (var i = 0; i < 3; i++) {
          var ly = planY + 10 + i * 7;
          var lw = planW * (0.7 - i * 0.1);
          ctx.beginPath();
          ctx.moveTo(planX + (planW - lw)/2, ly);
          ctx.lineTo(planX + (planW + lw)/2, ly);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;

        /* Process circle */
        ctx.fillStyle = PROCESS_COLOR;
        ctx.globalAlpha = 0.06;
        ctx.beginPath();
        ctx.arc(procX, h/2, procR, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.strokeStyle = PROCESS_COLOR;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 3]);
        ctx.beginPath();
        ctx.arc(procX, h/2, procR, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);

        /* Process label */
        ctx.fillStyle = PROCESS_COLOR;
        ctx.font = "600 10px " + getComputedStyle(document.body).getPropertyValue("--mono");
        ctx.fillText("AI", procX, h/2 + 4);

        /* Settled artifacts */
        for (var j = 0; j < artifacts.length; j++) {
          var a = artifacts[j];
          ctx.fillStyle = a.color;
          ctx.globalAlpha = 0.85;
          ctx.beginPath();
          roundRect(ctx, a.x, a.y, a.w, a.h, 3);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      function roundRect(ctx, x, y, w, h, r) {
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
      }

      /* Bezier path from plan → process → artifact zone */
      function flowPath(w, h, idx, total) {
        var planCx = w * 0.08 + w * 0.12;
        var planCy = h * 0.25 + h * 0.25;
        var procX = w * 0.38;
        var procY = h / 2;
        var artifactX = w * 0.62 + (idx / total) * w * 0.28;
        var spread = (idx / (total - 1 || 1) - 0.5) * h * 0.5;
        var artifactY = h / 2 + spread;

        return {
          /* start at plan edge */
          sx: planCx, sy: planCy,
          /* control point 1: toward process */
          c1x: planCx + (procX - planCx) * 0.5, c1y: planCy - 20 + spread * 0.3,
          /* control point 2: past process toward artifacts */
          c2x: procX + (artifactX - procX) * 0.4, c2y: procY + spread * 0.6,
          /* end at artifact position */
          ex: artifactX, ey: artifactY,
        };
      }

      function bezierPoint(p, t) {
        var u = 1 - t;
        return {
          x: u*u*u*p.sx + 3*u*u*t*p.c1x + 3*u*t*t*p.c2x + t*t*t*p.ex,
          y: u*u*u*p.sy + 3*u*u*t*p.c1y + 3*u*t*t*p.c2y + t*t*t*p.ey,
        };
      }

      /* Initial draw */
      drawScene(g());

      btn.addEventListener("click", function () {
        btn.disabled = true;
        cycles++;

        var w = W(), h = H();
        var particles = [];
        for (var i = 0; i < PARTICLE_COUNT; i++) {
          particles.push({
            path: flowPath(w, h, i, PARTICLE_COUNT),
            delay: i * 80,
            color: ARTIFACT_COLORS[i % ARTIFACT_COLORS.length],
            r: 4,
          });
        }

        var start = null;
        function frame(ts) {
          if (!start) start = ts;
          var el = ts - start;
          var ctx = g();
          drawScene(ctx);

          var allDone = true;
          for (var i = 0; i < particles.length; i++) {
            var p = particles[i];
            var localT = (el - p.delay) / FLOW_MS;
            if (localT < 0) { allDone = false; continue; }
            if (localT > 1) localT = 1; else allDone = false;

            var et = ease(localT);
            var pos = bezierPoint(p.path, et);

            /* trail */
            var steps = 8;
            for (var s = 0; s < steps; s++) {
              var tt = et - (s / steps) * 0.15;
              if (tt < 0) continue;
              var tp = bezierPoint(p.path, tt);
              ctx.globalAlpha = (1 - s / steps) * 0.3;
              ctx.beginPath();
              ctx.arc(tp.x, tp.y, p.r * (1 - s / steps * 0.5), 0, Math.PI * 2);
              ctx.fillStyle = p.color;
              ctx.fill();
            }

            /* main dot */
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, p.r, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
          }
          ctx.globalAlpha = 1;

          if (!allDone) {
            requestAnimationFrame(frame);
          } else {
            /* Add new artifacts */
            var artBaseX = w * 0.62;
            var artW = 14, artH = 18;
            var cols = Math.floor((w * 0.32) / (artW + 4));
            for (var j = 0; j < PARTICLE_COUNT; j++) {
              var idx = artifacts.length;
              var col = idx % cols;
              var row = Math.floor(idx / cols);
              artifacts.push({
                x: artBaseX + col * (artW + 4),
                y: h * 0.2 + row * (artH + 4),
                w: artW, h: artH,
                color: ARTIFACT_COLORS[j % ARTIFACT_COLORS.length],
              });
            }
            drawScene(g());
            btn.disabled = false;
            ft.className = "panel-foot teal";
            ft.textContent = "Cycle #" + cycles + " \u2014 " + artifacts.length +
              " artifact" + (artifacts.length === 1 ? "" : "s") + " produced. Foundation stable.";
          }
        }
        requestAnimationFrame(frame);
      });
    })();
    </script>
  </body>
</html>
