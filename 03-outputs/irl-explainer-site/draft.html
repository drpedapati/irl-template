<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AI Work You Can Retrace — Idempotent Research Loop</title>
    <style>
      :root {
        --bg: #ffffff;
        --ink: #111827;
        --muted: #4b5563;
        --subtle: #6b7280;
        --border: #e5e7eb;
        --sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        background: linear-gradient(180deg, #ffffff 0%, #fbfbfb 70%, #ffffff 100%);
        color: var(--ink);
        font-family: var(--sans);
        line-height: 1.7;
      }
      .topbar {
        position: sticky; top: 0; z-index: 50;
        background: rgba(255,255,255,0.82);
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--border);
      }
      .topbar-inner {
        max-width: 700px; margin: 0 auto;
        padding: 12px 18px;
        display: flex; align-items: center; justify-content: space-between;
      }
      .brand {
        display: inline-flex; align-items: center; gap: 10px;
        font-weight: 650; color: var(--ink); text-decoration: none;
      }
      .brand svg { width: 14px; height: 14px; display: block; }
      .topbar a.util {
        font-family: var(--mono); font-size: 12px;
        color: var(--subtle); text-decoration: none;
      }
      .topbar a.util:hover { color: var(--ink); text-decoration: none; }
      .wrap { max-width: 700px; margin: 0 auto; padding: 28px 18px 80px; }

      header { padding: 26px 0 22px; border-bottom: 1px solid var(--border); }
      .title-block { text-align: center; padding-bottom: 20px; }
      .kicker {
        font-family: var(--mono); font-size: 12px;
        letter-spacing: 0.08em; text-transform: uppercase;
        color: var(--subtle); margin-bottom: 10px;
      }
      h1 {
        font-size: clamp(34px, 4.2vw, 48px);
        line-height: 1.1; letter-spacing: -0.02em; margin: 0 0 8px;
      }
      .subtitle {
        font-family: var(--mono); font-size: 14px;
        letter-spacing: 0.04em; color: var(--subtle); margin: 0 0 10px;
      }
      .byline {
        font-family: var(--mono); font-size: 12.5px;
        color: var(--subtle); margin: -2px 0 14px;
      }
      .lede { color: var(--muted); font-size: 17px; margin: 12px 0; }
      .lede:first-of-type { margin-top: 0; }

      section {
        padding-top: 22px; margin-top: 22px;
        border-top: 1px solid var(--border);
      }
      h2 {
        font-size: 24px; line-height: 1.25; letter-spacing: -0.01em;
        margin: 0 0 10px; padding-bottom: 6px;
        border-bottom: 1px solid var(--border);
      }
      .subhead { color: var(--muted); margin: 0 0 10px; }
      .aside {
        border-left: 3px solid var(--border);
        padding-left: 14px; margin: 16px 0; color: var(--muted);
      }

      .toy-placeholder {
        border: 2px dashed var(--border);
        border-radius: 10px;
        padding: 18px 16px;
        margin: 18px 0;
        background: #fafafa;
        text-align: center;
      }
      .toy-placeholder .toy-name {
        font-weight: 700; font-size: 14px; margin-bottom: 4px;
      }
      .toy-placeholder .toy-desc {
        font-size: 13px; color: var(--subtle);
      }

      pre {
        margin: 14px 0;
        padding: 12px 12px;
        border-radius: 10px;
        background: #0b1020;
        color: #e5e7eb;
        overflow: auto;
        font-family: var(--mono);
        font-size: 12.5px;
        line-height: 1.55;
        border: 1px solid rgba(17, 24, 39, 0.25);
      }

      code {
        font-family: var(--mono);
      }

      .inline-code {
        background: #f3f4f6;
        padding: 0.1rem 0.25rem;
        border-radius: 6px;
        border: 1px solid var(--border);
        font-size: 0.92em;
      }

      footer {
        margin-top: 28px; padding-top: 18px;
        border-top: 1px solid var(--border);
        color: var(--subtle); font-size: 13px;
      }
    </style>
  </head>
  <body>
    <header class="topbar">
      <div class="topbar-inner">
        <a class="brand" href="#">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <circle cx="8" cy="8" r="6" fill="none" stroke="currentColor" stroke-width="1.5"></circle>
            <circle cx="8" cy="8" r="2" fill="currentColor"></circle>
          </svg>
          IRL Explainer
        </a>
        <a
          class="util"
          href="https://github.com/drpedapati/irl-template"
          target="_blank"
          rel="noopener noreferrer"
        >
          View Source
        </a>
      </div>
    </header>
    <div class="wrap">

      <!-- ═══════════════════════════════════════════════
           HEADER / LEDE
           ═══════════════════════════════════════════════ -->
      <header>
        <div class="title-block">
          <div class="kicker">A practical way to use AI &mdash; no vendor lock-in</div>
          <h1>AI Work You Can Retrace</h1>
          <div class="subtitle">Idempotent Research Loop</div>
          <div class="byline">Ernest Pedapati, MD</div>
        </div>

        <p class="lede">
          You want to use AI to get real work done. Not a demo, not a party
          trick &mdash; actual projects you can build on, share with
          colleagues, and return to months later. But most AI tools want you
          locked into their platform, and the landscape shifts every few
          months. What if you could learn one way of working with AI that
          doesn't depend on any particular product and produces work you
          actually own?
        </p>

        <p class="lede">
          Here is the problem most people run into: you do something
          genuinely useful with an AI assistant, it works, you feel
          productive &mdash; and then the whole thing evaporates into a chat
          transcript nobody will ever read again. A week later you can't
          answer basic questions. What inputs did you use? What assumptions
          did you make? If the result is wrong, where exactly did it go
          wrong?
        </p>

        <p class="lede">
          Think about the difference between cooking from memory and cooking
          from a recipe. From memory, you might make something great, but
          you can't teach it to someone else, you can't reliably make it
          again, and if something goes wrong you're just guessing at what
          changed. A recipe externalizes the knowledge. You can trace
          problems, share it with others, and build on it deliberately.
        </p>

        <p class="lede">
          IRL is a recipe for AI-assisted work. It isn't tied to any
          commercial product &mdash; it works with any AI assistant,
          whether that's Claude, ChatGPT, Copilot, a local model, or
          whatever comes next. You write a plan file that spells out your
          inputs, assumptions, and what the output should look like. The AI
          follows the plan and produces files you can actually inspect: a
          report, a dataset, a diagram. "Idempotent" just means: same
          recipe, same ingredients, same dish.
        </p>

        <p class="lede">
          The design plays to what each side is good at. You decide what
          matters, judge quality, and notice when something is off. The AI
          processes data, generates drafts, and follows instructions without
          getting tired. Your expertise drives the work &mdash; this isn't
          about AI features or knowing how to write code. It's about your
          judgment, your reasoning, and critically reviewing the output,
          like managing any capable assistant.
        </p>

        <p class="lede">
          This is worth learning because it's the thing that builds all the
          other things. A report, a data analysis, a literature review, a
          website, a grant draft &mdash; they're all just different
          instructions in the same kind of plan. Learn the pattern once and
          you have a way to manage any AI-assisted project that needs to be
          traceable, revisable, and yours.
        </p>
      </header>

      <main>

        <!-- ═══════════════════════════════════════════════
             SECTION 1: Why Learn This
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>1. Why Learn This</h2>
          <p class="subhead">
            One pattern that works for any AI-assisted project. No vendor lock-in. Just files.
          </p>

          <p>
            Most people who want to use AI productively feel stuck. The tools
            keep changing, results vanish into chat windows, and every
            platform wants you locked in. You invest time learning one
            product's interface, and six months later it's been replaced by
            the next thing. Meanwhile, the actual work you produced is
            trapped inside someone else's system.
          </p>

          <p>
            IRL is different. It's a plain-text pattern, not a product. The
            plan file you write is just a text document &mdash; any AI
            assistant can read it. The outputs are files on your computer
            that you own. Nothing is stored inside a proprietary platform.
            If you switch AI providers tomorrow, the pattern still works
            exactly the same way.
          </p>

          <p>
            The payoff is that you learn one workflow and can use it to build
            almost anything: a website, a data analysis, a literature
            review, an internal report, a conference poster. The structure
            stays the same; only the instructions change. Instead of
            learning a new tool for every type of project, you learn one way
            of thinking and apply it everywhere.
          </p>

          <div class="toy-placeholder">
            <div class="toy-name">Toy 7: One Pattern, Many Projects</div>
            <div class="toy-desc">
              Morphing animation showing the same plan structure with three different
              use cases (website, data analysis, literature review). Drives home:
              learn once, build anything.
            </div>
          </div>
        </section>

        <!-- ═══════════════════════════════════════════════
             SECTION 2: Your Expertise, Not the AI's
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>2. Your Expertise, Not the AI's</h2>
          <p class="subhead">
            This isn't about AI features or code. It's about your reasoning,
            your judgment, and your critical review of the output.
          </p>

          <p>
            The elephant in the room: AI makes mistakes. But so do human
            assistants, and so do we. The difference isn't whether mistakes
            happen &mdash; it's whether you have a system for catching them.
            IRL puts you in the driver's seat. You write out your reasoning
            in the plan. The AI produces a draft. Then you review the
            actual output critically &mdash; not the AI's process, but the
            files it produced. If something is wrong, you loop back: clarify
            your instructions, ask for a different approach, and run again
            until the output earns your trust.
          </p>

          <p>
            This is no different from managing a capable human assistant. You
            wouldn't hand someone a vague instruction and blindly accept the
            result. You'd review the work, redirect where needed, and
            refine until it meets your standards. IRL gives that natural
            feedback loop a stable structure so nothing falls through the
            cracks.
          </p>

          <p>
            The key point: this is about your domain expertise, not AI
            features. You don't need to understand how the AI works
            internally. You need to know your subject well enough to
            evaluate what it produces. The AI doesn't need to be perfect. It
            needs to be directable. And you need a system for reviewing what
            comes back.
          </p>

          <div class="toy-placeholder">
            <div class="toy-name">Toy 8: The Review Loop</div>
            <div class="toy-desc">
              Animated visualization of the trust-building cycle: you state
              reasoning &rarr; AI produces output &rarr; you review critically
              &rarr; spot an issue &rarr; clarify/redirect &rarr; AI revises
              &rarr; you verify &rarr; trust grows. Shows 3 iterations where
              output quality improves and a "confidence" indicator rises.
            </div>
          </div>
        </section>

        <!-- ═══════════════════════════════════════════════
             SECTION 3: Same Recipe, Same Result
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>3. Same Recipe, Same Result</h2>
          <p class="subhead">
            The core concept in plain language: run it again, get the same thing.
          </p>

          <p>
            The word "idempotent" sounds technical, but the idea is simple.
            If you follow the same recipe with the same ingredients, you
            should get the same dish. That's the foundation IRL is built on.
            When you run a step in your plan, it should produce the same
            output every time, as long as the inputs haven't changed. No
            surprises, no mystery differences.
          </p>

          <p>
            Why does this matter? Because the fastest way to lose trust in
            your work is to run the same step twice and get different results.
            If you can't explain what changed, you can't trust the output.
            Idempotency gives you confidence: if you rerun something and
            nothing is different, you know the foundation is solid. If
            something did change, you know exactly where to look because
            only the parts you deliberately modified should be different.
          </p>

          <p>
            In practice, this means a few simple habits: give your output
            files stable names (not names with today's date stamped on them),
            spell out where inputs come from, and avoid steps that depend on
            "whatever the latest version is" without pinning what that means.
            These are small disciplines, but they're the difference between
            work you can build on and work that slowly drifts out from under
            you.
          </p>

          <div class="toy-placeholder">
            <div class="toy-name">Toy 1: Idempotent vs. Non-Idempotent</div>
            <div class="toy-desc">
              Side-by-side constellation animation. Teal side always settles into the
              same shape; amber side drifts and accumulates dots each run. Visual,
              immediate, no jargon.
            </div>
          </div>
        </section>

        <!-- ═══════════════════════════════════════════════
             SECTION 4: The Human-AI Loop
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>4. The Human-AI Loop</h2>
          <p class="subhead">
            You reason and plan. The AI executes. A report grows.
          </p>

          <p>
            The first move is small but important: instead of keeping "what
            we're trying to do" inside a chat thread, you keep it in a file.
            That file is your control surface &mdash; the plan. It's where
            you state your objectives, your inputs, what the output should
            look like, and what "done" means. When something needs to change,
            you edit the plan, not your memory of a conversation.
          </p>

          <p>
            The loop itself is deliberately repetitive. You edit the plan,
            the AI executes the instructions, it produces files you can
            inspect, you review what it made, save a checkpoint, and repeat.
            If any of those steps is missing, the whole thing tends to
            collapse back into "chat with an AI until it feels done."
            Notice what isn't in the loop: "remember." IRL assumes memory is
            unreliable. The plan file replaces memory as the source of
            truth, and the outputs replace "trust me" explanations as
            evidence.
          </p>

          <p>
            The division of labor is clear. You bring the judgment: what
            matters, what's correct, what to do next. The AI brings the
            labor: processing data, generating drafts, following
            instructions without getting tired. The plan file sits between
            you as a shared contract. It isn't tied to any specific AI
            product &mdash; it's plain text that any assistant can read.
          </p>

          <p class="aside">
            A practical rule of thumb: keep each run short enough that you
            can rerun it without dread. If a run takes thirty seconds to a
            few minutes, you'll iterate freely. If it takes half an hour,
            you'll avoid reruns, and that's where mistakes hide.
          </p>

          <div class="toy-placeholder">
            <div class="toy-name">Toy 2: The Loop</div>
            <div class="toy-desc">
              Canvas animation showing HUMAN &harr; AI &rarr; REPORT triangle.
              Particles flow along plan/execute/review paths. Report card grows
              each cycle. Activity hints accumulate in margins.
            </div>
          </div>
        </section>

        <!-- ═══════════════════════════════════════════════
             SECTION 5: Watching It Work
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>5. Watching It Work</h2>
          <p class="subhead">
            A concrete walkthrough: the plan executes, outputs appear, a revision adds detail.
          </p>

          <p>
            Here's what a single run actually feels like. You open the plan,
            which spells out what the AI should do: read these inputs,
            produce these outputs, put them in these locations. You tell
            the AI to execute. It reads the plan, processes the inputs, and
            writes the results to the files you specified. You look at what
            it produced. If everything is right, you save a checkpoint. If
            something needs adjustment, you note the revision in the plan
            and run again.
          </p>

          <p>
            The second run is where it gets interesting. Say the first pass
            produced a summary table, but you want confidence intervals
            added. You write that revision into the plan: "add 95%
            confidence intervals to the summary table." You run again. The
            AI reads the updated plan, sees the new instruction, and
            produces a revised output. You review just the parts that
            changed. The rest should be untouched &mdash; and if it is,
            you know the foundation is stable.
          </p>

          <p>
            A good run is boring: it changes the files you expected,
            produces the artifacts you asked for, and leaves everything else
            alone. The boring part is the point. Once runs are predictable,
            collaboration becomes easier &mdash; colleagues can trust the
            structure, review what changed, and rerun steps without fear of
            breaking something.
          </p>

          <div class="toy-placeholder">
            <div class="toy-name">Toy 3: The Process</div>
            <div class="toy-desc">
              Side-by-side DOM animation. Plan on the left (Before / Instruction /
              After Each Loop sections highlight in sequence). Outputs accumulate on
              the right. Two loops with a revision between them showing iterative
              refinement.
            </div>
          </div>
        </section>

        <!-- ═══════════════════════════════════════════════
             SECTION 6: Inside the Plan
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>6. Inside the Plan</h2>
          <p class="subhead">
            What the plan file actually looks like. Click each section to learn what it does.
          </p>

          <p>
            The plan file is the centerpiece of every IRL project. It's a
            plain text document &mdash; you can open it in any editor &mdash;
            divided into a few clear sections. Think of it as a contract
            between you and the AI: you state what you want, and the AI
            follows the instructions to produce it.
          </p>

          <p>
            The structure is designed so the AI knows what to do without
            being told twice. A <strong>First-Time Setup</strong> section
            handles one-time preparation, like creating folders or
            downloading reference data. A <strong>Before Each Loop</strong>
            section covers pre-flight checks that should happen every run.
            The <strong>Instruction Loop</strong> is the heart of the plan
            &mdash; the actual tasks the AI executes, in order. An
            <strong>After Each Loop</strong> section handles cleanup and
            logging. And <strong>Formatting Guidelines</strong> keep the
            outputs consistent.
          </p>

          <p>
            The important thing is that this is the one place where your
            intent lives. When you want to change what the project does, you
            edit this file. When you want to understand what the project did,
            you read this file. When a colleague wants to reproduce your
            work, they start with this file. Everything flows from the plan.
          </p>

          <div class="toy-placeholder">
            <div class="toy-name">Toy 4: Anatomy of a Plan</div>
            <div class="toy-desc">
              Split layout: plan document on the left with realistic content,
              clickable section labels with colored dots on the right. Click a
              section to highlight both sides and see a description.
            </div>
          </div>
        </section>

        <!-- ═══════════════════════════════════════════════
             SECTION 7: Running the Plan
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>7. Running the Plan</h2>
          <p class="subhead">
            One command, run over and over. That's the whole routine.
          </p>

          <p>
            Executing the plan is intentionally simple. You open a
            terminal-based AI assistant and give it the same instruction
            every time: "Review main-plan.md, check for any revisions, and
            execute." The AI reads the plan, sees what needs to be done, and
            does the work. It produces the outputs you specified, updates the
            activity log, and stops.
          </p>

          <p>
            The repetition is the point. You don't need to re-explain the
            project each time. You don't need to remember where you left
            off. The plan file holds all of that context. Each run, the AI
            reads it fresh, checks what's changed since last time, and
            executes accordingly. If you added a revision &mdash; "add a
            conclusions section to the report" &mdash; it picks that up and
            acts on it.
          </p>

          <p>
            After the AI finishes, you review what it produced. If the
            output looks right, you save a checkpoint. If something needs
            adjustment, you edit the plan and run again. The rhythm becomes
            second nature: run, review, revise, run. Each cycle, the project
            gets a little more complete.
          </p>

          <div class="toy-placeholder">
            <div class="toy-name">Toy 5: The Execution Loop</div>
            <div class="toy-desc">
              Dark terminal animation. Three loops of the same command with
              revisions appearing between loops. Shows the rhythmic pattern of
              execute &rarr; review &rarr; revise &rarr; execute.
            </div>
          </div>
        </section>

        <!-- ═══════════════════════════════════════════════
             SECTION 8: Your Workspace
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>8. Your Workspace</h2>
          <p class="subhead">
            What the tools actually look like when you're working.
          </p>

          <p>
            When you sit down to work on an IRL project, you'll typically
            have a few things open. A text editor with the plan file, so
            you can read and revise your instructions. A preview pane or
            browser tab showing the output, so you can see what the AI
            produced. A terminal at the bottom where you run the AI
            assistant. And a file sidebar showing the project folder, so
            you can see what files exist and what's changed.
          </p>

          <p>
            No specific tool is required. This setup works in VS Code,
            Cursor, a plain text editor alongside a terminal window, or any
            combination you're comfortable with. The plan file is plain
            text, the outputs are regular files, and the AI assistant runs
            in the terminal. If you can edit a document and run a command,
            you have everything you need.
          </p>

          <p>
            The workspace mirrors the loop itself: plan on one side, output
            on the other, with the AI running between them. Once you've
            seen it, the layout becomes intuitive. You write in the plan,
            run the assistant, and watch the output appear or update in the
            preview. Review, revise, repeat.
          </p>

          <div class="toy-placeholder">
            <div class="toy-name">Toy 6: The Workspace</div>
            <div class="toy-desc">
              Interactive mock IDE layout. Four clickable zones (file explorer,
              plan editor, output preview, terminal) with overlay descriptions.
              Guided Tour button walks through each zone automatically.
            </div>
          </div>
        </section>

        <!-- ═══════════════════════════════════════════════
             SECTION 9: Extending with Skills
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>9. Extending with Skills</h2>
          <p class="subhead">
            Add capabilities without changing the pattern. Skills are plug-in
            instructions for different domains.
          </p>

          <p>
            Once you're comfortable with the basic loop, you can extend it
            with skills. A skill is simply a set of instructions that
            customizes the plan for a specific kind of work &mdash; searching
            medical literature, analyzing datasets, generating formatted
            documents, or building scientific posters. Skills plug into the
            plan file like recipes within a recipe.
          </p>

          <p>
            The key insight is that you never change how you work, only what
            the instructions say. A literature review skill might tell the
            AI how to search databases, extract key findings, and organize
            them into a structured summary. A data analysis skill might
            specify how to clean input files, run calculations, and produce
            figures. The loop is the same either way: run, review, revise.
          </p>

          <p>
            And because skills are just plain text, they aren't tied to any
            commercial product. You can share them with colleagues, adapt
            them for your specific needs, or write your own from scratch.
            They're instructions, not software. If you can describe what you
            want done, you can turn it into a skill.
          </p>
        </section>

        <!-- ═══════════════════════════════════════════════
             SECTION 10: Project Structure
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>10. Project Structure</h2>
          <p class="subhead">
            Where files live and why the layout matters.
          </p>

          <p>
            If you've ever inherited a project folder full of files named
            something like
            <span class="inline-code">final_v7_REAL_FINAL2.xlsx</span>, you
            already understand why a simple structure helps. IRL projects
            follow a clear convention: inputs and processed data are kept
            separate, outputs are the things you show people, and logs
            record what happened during each run.
          </p>

          <p>
            The separation between raw data and processed data is doing real
            work. Raw data is sacred &mdash; it should never be modified.
            Processed data is disposable: if it gets corrupted, you should
            be able to delete it and regenerate it by rerunning the plan
            from your raw inputs. Outputs are a different category entirely.
            They're the finished artifacts: a report, a figure, a table, a
            website. Outputs should have stable names so you can always find
            and compare them.
          </p>

          <p>
            The plan file sits at the top level as the entry point to the
            whole project. When someone opens the folder, the plan tells
            them what this project is, what it does, and how to run it.
            Everything else follows from there.
          </p>

          <pre><code>my-project/
&#9500;&#9472;&#9472; main-plan.md
&#9500;&#9472;&#9472; 02-data/
&#9474;   &#9500;&#9472;&#9472; raw/
&#9474;   &#9492;&#9472;&#9472; derived/
&#9500;&#9472;&#9472; 03-outputs/
&#9492;&#9472;&#9472; 04-logs/</code></pre>

          <p class="aside">
            If your data is too large to include in the project folder, you
            can still keep the contract: store the data elsewhere, record
            its location and a description in the plan, and make the steps
            to access it explicit. The structure is a convention, not a
            constraint.
          </p>
        </section>

        <!-- ═══════════════════════════════════════════════
             SECTION 11: Keeping It Reproducible
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>11. Keeping It Reproducible</h2>
          <p class="subhead">
            Practical habits for reproducibility: stable paths, pinned versions, no hidden assumptions.
          </p>

          <p>
            Reproducibility sounds like an abstract principle, but in
            practice it comes down to a few concrete habits. Give your
            output files stable names &mdash; avoid stamping today's date
            into the filename unless you specifically want a historical
            snapshot. Use explicit paths for inputs and outputs so the AI
            always reads from and writes to the same locations. And if a
            step depends on an external resource, pin the version so that
            "latest" today doesn't silently become something different next
            month.
          </p>

          <p>
            The review step is where reproducibility is tested. After the AI
            finishes a run, you look at what changed. Did it touch the files
            you expected? Did it accidentally modify something unrelated?
            Are there new outputs that shouldn't be there? The most
            important question is simple: does this change actually support
            the plan's goal, or did the AI just produce activity?
          </p>

          <p>
            Here is the strongest signal that your project is reproducible:
            if you run the same step again without changing anything, nothing
            should be different. The same inputs, the same plan, the same
            output. When a rerun produces no changes, you know the
            foundation is solid. And that means you can build on it with
            confidence, hand it to a colleague, or return to it months later
            and pick up exactly where you left off.
          </p>

          <p class="aside">
            If you can't make a step perfectly reproducible, the fallback is
            explicit: note what varies and why in the plan. The goal isn't
            perfection &mdash; it's transparency. A documented assumption is
            always better than a hidden one.
          </p>
        </section>

        <!-- ═══════════════════════════════════════════════
             SECTION 12: Getting Started — Plain Text
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>12. Getting Started: The Plain-Text Way</h2>
          <p class="subhead">
            All you need is a text file and a terminal-based AI assistant.
          </p>

          <p>
            The fastest way to start is also the simplest. Create a new
            folder for your project. Inside it, create a plain text file
            called <span class="inline-code">main-plan.md</span>. Open it
            and write down what you want to accomplish: your objective, your
            inputs, what the output should look like, and how you'll know
            it's done. You don't need a special template &mdash; even a few
            clear sentences will work.
          </p>

          <p>
            Then open a terminal-based AI assistant &mdash; Claude Code,
            Cursor, Copilot, or any tool that can read files and follow
            instructions. Give it one instruction: "Review main-plan.md,
            check for any revisions, and execute." The AI reads your plan,
            does the work, and produces the files you asked for. You review
            the output. If something needs adjusting, add a revision to
            the plan and run again.
          </p>

          <p>
            That's the entire workflow. No installation, no configuration,
            no account to set up. The plan file is yours, the outputs are
            yours, and the pattern works with whatever AI assistant you
            have access to. You can be running your first project in under
            five minutes.
          </p>

          <p class="aside">
            IRL is a pattern, not a product. Starting with plain text
            reinforces that. Once you're comfortable with the loop, you can
            add structure gradually &mdash; separate folders for data and
            outputs, a log file, version control. But none of that is
            required to begin.
          </p>
        </section>

        <!-- ═══════════════════════════════════════════════
             SECTION 13: Getting Started — IRL CLI
             ═══════════════════════════════════════════════ -->
        <section>
          <h2>13. Getting Started: The IRL App</h2>
          <p class="subhead">
            A lightweight app that sets up the project structure for you.
          </p>

          <p>
            If you'd rather skip the manual setup, the IRL app creates a
            properly structured project in one step. Give it a short
            description of your project, and it builds the folder layout
            automatically: a plan file ready for editing, separate
            directories for data, outputs, and logs, and a date-stamped
            project name so your work is organized from the start.
          </p>

          <p>
            The app also supports templates. If you're doing a literature
            review, a data analysis, or building a website, you can start
            from a pre-written plan that already has the right structure
            for that kind of project. Templates are just starting points
            &mdash; you'll customize the plan to fit your specific goals,
            but they save you from writing the boilerplate sections from
            scratch.
          </p>

          <p>
            It's important to understand what the app is and isn't. It's a
            convenience layer that produces the same plain-text structure
            from Section 12, just faster. Everything it creates is files you
            own &mdash; plain text, in folders on your computer. The app is
            open source and entirely optional. If you prefer to set things
            up by hand, that works just as well.
          </p>

          <p class="aside">
            The IRL app is available on GitHub. Installation is a single
            command, and the project it creates works immediately with any
            terminal-based AI assistant.
          </p>
        </section>

      </main>

      <footer>
        Built with IRL &mdash; a document-centric workflow for AI-assisted work.
      </footer>

    </div>
  </body>
</html>
