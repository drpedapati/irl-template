<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Toy Playground — IRL</title>

    <style>
      :root {
        --ink: #111827;
        --muted: #4b5563;
        --subtle: #6b7280;
        --border: #e5e7eb;
        --teal: #0d9488;
        --teal-light: #ccfbf1;
        --amber: #d97706;
        --amber-light: #fef3c7;

        --sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }

      body {
        margin: 0;
        background: linear-gradient(180deg, #fff 0%, #f9fafb 50%, #fff 100%);
        color: var(--ink);
        font-family: var(--sans);
        line-height: 1.7;
        text-rendering: optimizeLegibility;
      }

      .topbar {
        position: sticky; top: 0; z-index: 50;
        background: rgba(255,255,255,0.82);
        -webkit-backdrop-filter: blur(10px);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--border);
      }
      .topbar-inner {
        max-width: 860px; margin: 0 auto; padding: 12px 18px;
        display: flex; align-items: center; justify-content: space-between; gap: 12px;
      }
      .brand {
        display: inline-flex; align-items: center; gap: 10px;
        font-weight: 650; color: var(--ink); text-decoration: none; letter-spacing: -0.01em;
      }
      .brand svg { width: 14px; height: 14px; display: block; }
      .topbar a.util {
        font-family: var(--mono); font-size: 12px; color: var(--subtle); text-decoration: none;
      }
      .topbar a.util:hover { color: var(--ink); }

      .wrap { max-width: 860px; margin: 0 auto; padding: 28px 18px 80px; }

      .page-header {
        padding: 30px 0 24px; border-bottom: 1px solid var(--border); text-align: center;
      }
      h1 {
        font-size: clamp(28px, 3.5vw, 40px); line-height: 1.1;
        letter-spacing: -0.02em; margin: 0 0 8px;
      }
      .page-subtitle { font-family: var(--mono); font-size: 13px; color: var(--subtle); }

      p { margin: 12px 0; }

      h2 {
        font-size: 22px; line-height: 1.25; letter-spacing: -0.01em;
        margin: 32px 0 6px; padding-bottom: 6px; border-bottom: 1px solid var(--border);
      }
      .intro {
        color: var(--muted); font-size: 16px;
        max-width: 580px; margin: 10px auto 20px; text-align: center;
      }

      .contrast { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
      @media (max-width: 600px) { .contrast { grid-template-columns: 1fr; } }

      .panel {
        border: 1px solid var(--border); border-radius: 12px;
        background: #fff; overflow: hidden;
      }
      .panel-head {
        padding: 12px 14px 8px;
        display: flex; align-items: center; justify-content: space-between;
      }
      .panel-label {
        font-family: var(--mono); font-size: 11px; font-weight: 600;
        letter-spacing: 0.08em; text-transform: uppercase;
      }
      .panel-label.teal { color: var(--teal); }
      .panel-label.amber { color: var(--amber); }

      .run-btn {
        font-family: var(--mono); font-size: 11px; padding: 4px 10px;
        border-radius: 6px; border: 1px solid var(--border);
        background: #fff; cursor: pointer; transition: background 0.15s;
      }
      .run-btn:hover { background: #f9fafb; }
      .run-btn:disabled { cursor: not-allowed; opacity: 0.4; }

      .canvas-wrap {
        position: relative; width: 100%; aspect-ratio: 5 / 3;
        background: #fafafa; border-top: 1px solid var(--border);
      }
      .canvas-wrap canvas {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      }

      .panel-foot {
        padding: 8px 14px; font-family: var(--mono); font-size: 11px;
        line-height: 1.4; border-top: 1px solid var(--border);
        min-height: 34px; transition: background 0.4s, color 0.4s;
      }
      .panel-foot.neutral { background: #f9fafb; color: var(--subtle); }
      .panel-foot.teal { background: var(--teal-light); color: var(--teal); }
      .panel-foot.amber { background: var(--amber-light); color: var(--amber); }

      .aside {
        border-left: 3px solid var(--border); padding-left: 14px;
        margin: 22px 0; color: var(--muted); font-size: 15px;
      }

      footer {
        margin-top: 28px; padding-top: 18px;
        border-top: 1px solid var(--border); color: var(--subtle); font-size: 13px;
      }
      a {
        color: var(--ink); text-decoration: underline;
        text-underline-offset: 2px; text-decoration-thickness: 1px;
      }
      a:hover { text-decoration: none; }
      a:focus-visible, button:focus-visible { outline: 2px solid var(--ink); outline-offset: 2px; }
    </style>
  </head>
  <body>
    <header class="topbar">
      <div class="topbar-inner">
        <a class="brand" href="index.html" aria-label="Back to explainer">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <circle cx="8" cy="8" r="6" fill="none" stroke="currentColor" stroke-width="1.5"></circle>
            <circle cx="8" cy="8" r="2" fill="currentColor"></circle>
          </svg>
          IRL Toys
        </a>
        <a class="util" href="index.html">Back to Explainer</a>
      </div>
    </header>

    <div class="wrap">
      <div class="page-header">
        <h1>Toy Playground</h1>
        <div class="page-subtitle">Design experiments for IRL concepts</div>
      </div>

      <h2>Idempotent vs. Non-Idempotent</h2>
      <p class="intro">
        Press Run on each side. One constellation always forms the same shape.
        The other never does.
      </p>

      <div class="contrast">
        <div class="panel">
          <div class="panel-head">
            <span class="panel-label teal">Idempotent</span>
            <button class="run-btn" id="idem-btn" type="button">Run</button>
          </div>
          <div class="canvas-wrap"><canvas id="cv-idem"></canvas></div>
          <div class="panel-foot neutral" id="ft-idem">Same recipe, same dish. Press Run.</div>
        </div>
        <div class="panel">
          <div class="panel-head">
            <span class="panel-label amber">Non-Idempotent</span>
            <button class="run-btn" id="nonidem-btn" type="button">Run</button>
          </div>
          <div class="canvas-wrap"><canvas id="cv-nonidem"></canvas></div>
          <div class="panel-foot neutral" id="ft-nonidem">Same recipe, different dish. Press Run.</div>
        </div>
      </div>

      <p class="aside">
        The teal side is safe to rerun: the constellation always settles into
        the same shape. The amber side drifts: positions shift, new dots appear,
        and you can't tell which run was "right." Idempotency is what makes
        iteration trustworthy.
      </p>

      <h2>The Loop</h2>
      <p class="intro">
        You plan, the AI executes, and a report takes shape. Each cycle
        adds detail &mdash; watch instructions accumulate in the margins
        as the work happens.
      </p>

      <div class="panel" style="max-width:100%">
        <div class="panel-head">
          <span class="panel-label" style="color:var(--subtle)">Human &harr; AI &rarr; Report</span>
          <button class="run-btn" id="recipe-btn" type="button">Run Cycle</button>
        </div>
        <div class="canvas-wrap" style="aspect-ratio:5/2.5"><canvas id="cv-recipe"></canvas></div>
        <div class="panel-foot neutral" id="ft-recipe">Watching the loop&hellip;</div>
      </div>

      <p class="aside">
        You write a plan with your instructions. The AI reads it and produces
        a report. As each cycle runs, planning appears on the left, execution
        on the right &mdash; a visible trail of the work. You review the output,
        refine your plan, and loop again. Each pass builds on the last.
      </p>

      <h2>The Process</h2>
      <p class="intro">
        Watch a plan execute across two loops &mdash; including a revision.
        The left side is the plan; the right side is what gets produced.
      </p>

      <div class="panel" style="max-width:100%" id="process-panel">
        <div class="panel-head">
          <span class="panel-label" style="color:var(--subtle)">Plan &rarr; Execute &rarr; Revise &rarr; Repeat</span>
          <button class="run-btn" id="process-btn" type="button">Play</button>
        </div>
        <div id="process-stage" style="padding:14px 16px;min-height:300px;font-family:var(--mono);font-size:12px;line-height:1.55;background:#fafafa;border-top:1px solid var(--border);overflow:hidden;position:relative">
        </div>
        <div class="panel-foot neutral" id="ft-process">Watch the IRL loop in action.</div>
      </div>

      <p class="aside">
        Each loop follows the same structure: check prerequisites, execute
        instructions, save a checkpoint. When the author adds a revision,
        the next loop picks it up and improves the output. Nothing is hidden
        in chat history &mdash; it all lives in files you can inspect.
      </p>

      <footer><a href="index.html">Back to the explainer</a></footer>
    </div>

    <script>
    (function () {
      var N = 12;
      var R = 5;
      var LINE_DIST = 80;
      var SCATTER_MS = 300;
      var SETTLE_MS = 800;

      function ease(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }

      /* ── Canvas boilerplate ── */
      function init(id) {
        var c = document.getElementById(id);
        var dpr = window.devicePixelRatio || 1;
        function fit() {
          var r = c.parentElement.getBoundingClientRect();
          c.width = r.width * dpr; c.height = r.height * dpr;
        }
        fit(); window.addEventListener("resize", fit);
        return { c: c, dpr: dpr, fit: fit };
      }
      function ctx(cv) {
        var g = cv.c.getContext("2d");
        g.setTransform(cv.dpr, 0, 0, cv.dpr, 0, 0);
        return g;
      }
      function dim(cv) { return { w: cv.c.width / cv.dpr, h: cv.c.height / cv.dpr }; }

      /* ── Seeded RNG (mulberry32) ── */
      function rng(s) {
        return function () {
          s |= 0; s = s + 0x6d2b79f5 | 0;
          var t = Math.imul(s ^ s >>> 15, 1 | s);
          t = (t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t;
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
      }

      function seededPts(n, w, h, seed) {
        var r = rng(seed), pad = R + 14, pts = [];
        for (var i = 0; i < n; i++)
          pts.push({ x: pad + r() * (w - 2*pad), y: pad + r() * (h - 2*pad) });
        return pts;
      }
      function randPts(n, w, h) {
        var pad = R + 14, pts = [];
        for (var i = 0; i < n; i++)
          pts.push({ x: pad + Math.random()*(w-2*pad), y: pad + Math.random()*(h-2*pad) });
        return pts;
      }

      /* ── Drawing ── */
      function draw(g, pts, colors, w, h, lineColor) {
        g.clearRect(0, 0, w, h);

        /* constellation lines */
        g.strokeStyle = lineColor;
        g.lineWidth = 1;
        for (var i = 0; i < pts.length; i++) {
          for (var j = i + 1; j < pts.length; j++) {
            var dx = pts[i].x - pts[j].x, dy = pts[i].y - pts[j].y;
            var d = Math.sqrt(dx*dx + dy*dy);
            if (d < LINE_DIST) {
              var a = 0.25 * (1 - d / LINE_DIST);
              g.globalAlpha = a;
              g.beginPath();
              g.moveTo(pts[i].x, pts[i].y);
              g.lineTo(pts[j].x, pts[j].y);
              g.stroke();
            }
          }
        }

        /* dots */
        for (var k = 0; k < pts.length; k++) {
          g.globalAlpha = pts[k].a !== undefined ? pts[k].a : 1;
          g.beginPath();
          g.arc(pts[k].x, pts[k].y, R, 0, Math.PI * 2);
          g.fillStyle = colors[k % colors.length];
          g.fill();
        }
        g.globalAlpha = 1;
      }

      /* ── Two-phase animation: scatter out, then settle ── */
      function animate(cv, from, to, colors, lineColor, done) {
        var d = dim(cv);
        /* Phase 1: scatter from current positions outward */
        var scattered = [];
        var cx = d.w / 2, cy = d.h / 2;
        for (var i = 0; i < to.length; i++) {
          var src = from[i] || { x: cx, y: cy };
          var angle = Math.atan2(src.y - cy, src.x - cx) + (Math.random()-0.5)*1.2;
          var dist = 30 + Math.random() * 40;
          scattered.push({
            x: src.x + Math.cos(angle) * dist,
            y: src.y + Math.sin(angle) * dist,
          });
        }

        var start = null;
        var totalMs = SCATTER_MS + SETTLE_MS;

        function frame(ts) {
          if (!start) start = ts;
          var el = ts - start;
          var g = ctx(cv);
          var pts = [];

          if (el < SCATTER_MS) {
            /* Phase 1: current → scattered */
            var t1 = ease(el / SCATTER_MS);
            for (var i = 0; i < to.length; i++) {
              var src = from[i] || { x: cx, y: cy };
              pts.push({
                x: src.x + (scattered[i].x - src.x) * t1,
                y: src.y + (scattered[i].y - src.y) * t1,
                a: from[i] ? 1 : t1,
              });
            }
          } else {
            /* Phase 2: scattered → target */
            var t2 = ease(Math.min((el - SCATTER_MS) / SETTLE_MS, 1));
            for (var j = 0; j < to.length; j++) {
              pts.push({
                x: scattered[j].x + (to[j].x - scattered[j].x) * t2,
                y: scattered[j].y + (to[j].y - scattered[j].y) * t2,
                a: from[j] ? 1 : Math.min(1, (el / SCATTER_MS)),
              });
            }
          }

          draw(g, pts, colors, d.w, d.h, lineColor);

          if (el < totalMs) {
            requestAnimationFrame(frame);
          } else {
            /* final clean draw at exact targets */
            draw(g, to.map(function(p) { return { x:p.x, y:p.y, a:1 }; }), colors, d.w, d.h, lineColor);
            if (done) done(to);
          }
        }
        requestAnimationFrame(frame);
      }

      /* ── Color palettes ── */
      var tealPalette = ["#0d9488","#14b8a6","#2dd4bf","#5eead4","#99f6e4","#0f766e"];
      var amberPalette = ["#d97706","#f59e0b","#fbbf24","#fcd34d","#b45309","#92400e"];

      function pickColors(n, palette, seed) {
        var r = rng(seed), out = [];
        for (var i = 0; i < n; i++) out.push(palette[Math.floor(r() * palette.length)]);
        return out;
      }

      /* ══════════════════════════════════════
         IDEMPOTENT
         ══════════════════════════════════════ */
      var iCv = init("cv-idem");
      var iBtn = document.getElementById("idem-btn");
      var iFt = document.getElementById("ft-idem");
      var iRuns = 0, iCur = null;
      var SEED = 42;
      var iCol = pickColors(N, tealPalette, SEED);

      (function () {
        var d = dim(iCv);
        iCur = randPts(N, d.w, d.h);
        draw(ctx(iCv), iCur, iCol, d.w, d.h, "rgba(13,148,136,0.35)");
      })();

      iBtn.addEventListener("click", function () {
        iBtn.disabled = true;
        iRuns++;
        var d = dim(iCv);
        var targets = seededPts(N, d.w, d.h, SEED);
        animate(iCv, iCur, targets, iCol, "rgba(13,148,136,0.35)", function (final) {
          iCur = final;
          iBtn.disabled = false;
          iFt.className = "panel-foot teal";
          iFt.textContent = iRuns === 1
            ? "Run #1 \u2014 constellation formed."
            : "Run #" + iRuns + " \u2014 identical shape. Nothing changed.";
        });
      });

      /* ══════════════════════════════════════
         NON-IDEMPOTENT
         ══════════════════════════════════════ */
      var nCv = init("cv-nonidem");
      var nBtn = document.getElementById("nonidem-btn");
      var nFt = document.getElementById("ft-nonidem");
      var nRuns = 0, nCur = null, nCount = N;
      var nCol = pickColors(N + 30, amberPalette, 99);

      (function () {
        var d = dim(nCv);
        nCur = randPts(N, d.w, d.h);
        draw(ctx(nCv), nCur, nCol, d.w, d.h, "rgba(217,119,6,0.3)");
      })();

      nBtn.addEventListener("click", function () {
        nBtn.disabled = true;
        nRuns++;
        var d = dim(nCv);
        var extra = Math.floor(Math.random() * 2) + 1;
        var newN = nCount + extra;
        var targets = randPts(newN, d.w, d.h);

        /* Pad from with center-spawns for new dots */
        var from = (nCur || []).slice();
        while (from.length < newN) from.push({ x: d.w/2, y: d.h/2 });

        animate(nCv, from, targets, nCol, "rgba(217,119,6,0.3)", function (final) {
          nCur = final;
          nCount = newN;
          nBtn.disabled = false;
          nFt.className = "panel-foot amber";
          nFt.textContent = nRuns === 1
            ? "Run #1 \u2014 " + newN + " dots, random positions."
            : "Run #" + nRuns + " \u2014 " + newN + " dots. Shape changed again.";
        });
      });
    })();

    /* ══════════════════════════════════════════════
       TOY 2: THE LOOP — human ↔ AI → artifacts
       ══════════════════════════════════════════════ */
    (function () {
      var cv = (function (id) {
        var c = document.getElementById(id);
        var dpr = window.devicePixelRatio || 1;
        function fit() {
          var r = c.parentElement.getBoundingClientRect();
          c.width = r.width * dpr; c.height = r.height * dpr;
        }
        fit(); window.addEventListener("resize", fit);
        return { c: c, dpr: dpr };
      })("cv-recipe");

      var btn = document.getElementById("recipe-btn");
      var ft = document.getElementById("ft-recipe");
      var cycles = 0;
      var reportVer = 0;
      var RLINE_W = [0.72,0.50,0.88,0.62,0.40,0.78,0.55,0.83,0.68];
      var autoPlaying = false;
      var mono = "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

      function getCtx() {
        var c = cv.c.getContext("2d");
        c.setTransform(cv.dpr, 0, 0, cv.dpr, 0, 0);
        return c;
      }
      function W() { return cv.c.width / cv.dpr; }
      function H() { return cv.c.height / cv.dpr; }
      function ease(t) { return t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2; }

      var HUMAN_C = "#0d9488";
      var AI_C = "#6b7280";
      var REVIEW_C = "#92400e";
      /* report line widths pre-defined in RLINE_W above */

      /* Activity hint snippets — from actual IRL instructions */
      var PLAN_HINTS = ["load survey data", "filter responses", "run t-test", "compute stats", "render report", "check inputs"];
      var EXEC_HINTS = ["reading data\u2026", "filtering rows\u2026", "computing means\u2026", "running t-test\u2026", "writing report\u2026", "saving output\u2026"];
      var hintLog = []; /* accumulated: {text, side:"h"|"a", born} */
      var hintSchedule = [], hintFired = 0;

      function drawAllHints(ctx) {
        var w = W(), now = performance.now();
        var hc = 0, ac = 0;
        for (var i = 0; i < hintLog.length; i++) {
          var ht = hintLog[i];
          var age = now - ht.born;
          var fadeIn = Math.min(age / 600, 1);
          var recency = hintLog.length - 1 - i;
          var baseA = Math.max(0.12, 0.45 - recency * 0.05);
          var alpha = fadeIn * baseA;
          if (alpha < 0.01) continue;
          ctx.font = "italic 10px " + mono;
          ctx.globalAlpha = alpha;
          if (ht.side === "h") {
            ctx.textAlign = "left"; ctx.fillStyle = HUMAN_C;
            ctx.fillText(ht.text, 8, 14 + hc * 14); hc++;
          } else {
            ctx.textAlign = "right"; ctx.fillStyle = AI_C;
            ctx.fillText(ht.text, w - 8, 14 + ac * 14); ac++;
          }
        }
        ctx.globalAlpha = 1;
      }

      function nodeR() { return Math.min(W(), H()) * 0.15; }

      function layout() {
        var w = W(), h = H();
        return { hx: w*0.22, hy: h*0.38, ax: w*0.78, ay: h*0.38, r: nodeR() };
      }

      /* Three bezier legs forming the loop */
      function loopPaths() {
        var w = W(), h = H(), L = layout(), r = L.r;
        return [
          /* 0: Human → AI (arc over top) */
          { sx: L.hx + r*0.85, sy: L.hy - r*0.5,
            c1x: w*0.38, c1y: h*0.08, c2x: w*0.62, c2y: h*0.08,
            ex: L.ax - r*0.85, ey: L.ay - r*0.5,
            color: HUMAN_C, label: "plan" },
          /* 1: AI → Files (curve down right) */
          { sx: L.ax + r*0.15, sy: L.ay + r,
            c1x: w*0.85, c1y: h*0.65, c2x: w*0.68, c2y: h*0.82,
            ex: w*0.58, ey: h*0.80,
            color: AI_C, label: "execute" },
          /* 2: Files → Human (curve up left) */
          { sx: w*0.42, sy: h*0.80,
            c1x: w*0.30, c1y: h*0.82, c2x: w*0.14, c2y: h*0.65,
            ex: L.hx - r*0.15, ey: L.hy + r,
            color: REVIEW_C, label: "review" },
        ];
      }

      function bezAt(p, t) {
        var u = 1 - t;
        return {
          x: u*u*u*p.sx + 3*u*u*t*p.c1x + 3*u*t*t*p.c2x + t*t*t*p.ex,
          y: u*u*u*p.sy + 3*u*u*t*p.c1y + 3*u*t*t*p.c2y + t*t*t*p.ey,
        };
      }

      function drawArrow(ctx, p) {
        var dx = p.ex - p.c2x, dy = p.ey - p.c2y;
        var len = Math.sqrt(dx*dx + dy*dy); dx /= len; dy /= len;
        var sz = 14, px = -dy*sz*0.5, py = dx*sz*0.5;
        ctx.fillStyle = p.color; ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.moveTo(p.ex, p.ey);
        ctx.lineTo(p.ex - dx*sz + px, p.ey - dy*sz + py);
        ctx.lineTo(p.ex - dx*sz - px, p.ey - dy*sz - py);
        ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1;
      }

      function drawNode(ctx, x, y, r, color, dashed, label, sub, glow) {
        if (glow > 0) {
          ctx.fillStyle = color; ctx.globalAlpha = 0.07 * glow;
          ctx.beginPath(); ctx.arc(x, y, r*1.6, 0, Math.PI*2); ctx.fill();
          ctx.globalAlpha = 1;
        }
        ctx.fillStyle = color; ctx.globalAlpha = 0.08 + 0.05*glow;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
        ctx.strokeStyle = color; ctx.lineWidth = 1.5;
        if (dashed) ctx.setLineDash([4,3]);
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = color;
        ctx.font = "700 20px " + mono;
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(label, x, y - 8);
        if (sub) {
          ctx.font = "400 14px " + mono; ctx.globalAlpha = 0.55;
          ctx.fillText(sub, x, y + 14); ctx.globalAlpha = 1;
        }
      }

      function roundRect(ctx, x, y, w, h, r) {
        ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y);
        ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r);
        ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h);
        ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r);
        ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath();
      }

      function drawScene(ctx, gh, ga) {
        var w = W(), h = H(), L = layout(), P = loopPaths();
        ctx.clearRect(0, 0, w, h);

        /* Loop paths + arrowheads + labels */
        for (var i = 0; i < P.length; i++) {
          var p = P[i];
          ctx.strokeStyle = p.color; ctx.globalAlpha = 0.35;
          ctx.lineWidth = 2; ctx.setLineDash([8,4]);
          ctx.beginPath();
          ctx.moveTo(p.sx, p.sy);
          ctx.bezierCurveTo(p.c1x, p.c1y, p.c2x, p.c2y, p.ex, p.ey);
          ctx.stroke();
          ctx.setLineDash([]); ctx.globalAlpha = 1;
          drawArrow(ctx, p);
          var mid = bezAt(p, 0.5);
          ctx.fillStyle = p.color; ctx.globalAlpha = 0.5;
          ctx.font = "600 15px " + mono;
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          var offY = i === 0 ? -14 : 0;
          var offX = i === 1 ? 18 : (i === 2 ? -18 : 0);
          ctx.fillText(p.label, mid.x + offX, mid.y + offY);
          ctx.globalAlpha = 1;
        }

        /* Nodes */
        drawNode(ctx, L.hx, L.hy, L.r, HUMAN_C, false, "HUMAN", "reason \xb7 plan", gh||0);
        drawNode(ctx, L.ax, L.ay, L.r, AI_C, true, "AI", "execute", ga||0);

        /* Report document */
        if (reportVer > 0) {
          var rw = 82, nLines = reportVer * 3;
          var rh = 24 + nLines * 8;
          var rx = w*0.50 - rw/2, ry = h*0.60;

          /* shadow */
          ctx.fillStyle = "#e5e7eb"; ctx.globalAlpha = 0.4;
          ctx.beginPath(); roundRect(ctx, rx+2, ry+2, rw, rh, 5); ctx.fill();

          /* card */
          ctx.fillStyle = "#fff"; ctx.globalAlpha = 1;
          ctx.beginPath(); roundRect(ctx, rx, ry, rw, rh, 5); ctx.fill();
          ctx.strokeStyle = "#d1d5db"; ctx.lineWidth = 1;
          ctx.beginPath(); roundRect(ctx, rx, ry, rw, rh, 5); ctx.stroke();

          /* label */
          ctx.fillStyle = AI_C; ctx.globalAlpha = 0.55;
          ctx.font = "600 11px " + mono; ctx.textAlign = "center";
          ctx.fillText("REPORT v" + reportVer, w*0.50, ry - 7);
          ctx.globalAlpha = 1;

          /* content lines */
          for (var l = 0; l < nLines; l++) {
            var fresh = l >= (nLines - 3);
            ctx.fillStyle = fresh ? HUMAN_C : "#9ca3af";
            ctx.globalAlpha = fresh ? 0.45 : 0.25;
            ctx.fillRect(rx+8, ry+10+l*8, (rw-16)*RLINE_W[l%RLINE_W.length], 3);
          }
          ctx.globalAlpha = 1;
        }

        /* Accumulated activity hints in margins */
        drawAllHints(ctx);
      }

      /* Particle drawing helper */
      function drawParticles(ctx, path, el, phaseStart, count, stagger, flowMs, color) {
        for (var i = 0; i < count; i++) {
          var lt = (el - phaseStart - i*stagger) / flowMs;
          if (lt < 0 || lt > 1) continue;
          var et = ease(lt);
          for (var s = 0; s < 6; s++) {
            var tt = et - (s/6)*0.12;
            if (tt < 0) continue;
            var tp = bezAt(path, tt);
            ctx.globalAlpha = (1-s/6)*0.25;
            ctx.beginPath();
            ctx.arc(tp.x, tp.y, 4.5*(1-s/6*0.4), 0, Math.PI*2);
            ctx.fillStyle = color; ctx.fill();
          }
          ctx.globalAlpha = 1;
          var pos = bezAt(path, et);
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, 4.5, 0, Math.PI*2);
          ctx.fillStyle = color; ctx.fill();
        }
      }

      /* Initial draw */
      drawScene(getCtx(), 0, 0);

      /* Animation timing */
      var PLAN_N = 3, EXEC_N = 3, REV_N = 2;
      var FLOW_MS = 700, STAGGER = 70;
      var phase1T = FLOW_MS + (PLAN_N-1)*STAGGER;
      var GAP = 80;
      var phase2S = phase1T + GAP;
      var phase2T = FLOW_MS + (EXEC_N-1)*STAGGER;
      var phase3S = phase2S + phase2T + GAP;
      var phase3T = FLOW_MS + (REV_N-1)*STAGGER;
      var totalT = phase3S + phase3T;

      function buildHintSchedule(n) {
        var b = (n - 1) % PLAN_HINTS.length;
        return [
          [phase1T * 0.25, PLAN_HINTS[b % PLAN_HINTS.length], "h"],
          [phase1T * 0.70, PLAN_HINTS[(b+1) % PLAN_HINTS.length], "h"],
          [phase2S + phase2T * 0.25, EXEC_HINTS[b % EXEC_HINTS.length], "a"],
          [phase2S + phase2T * 0.70, EXEC_HINTS[(b+1) % EXEC_HINTS.length], "a"],
          [phase3S + phase3T * 0.35, "check output\u2026", "h"],
        ];
      }

      /* Run one cycle, call onDone when finished */
      function runOneCycle(onDone) {
        btn.disabled = true;
        cycles++;
        hintSchedule = buildHintSchedule(cycles);
        hintFired = 0;
        var w = W(), h = H(), P = loopPaths();
        var t0 = null;

        function frame(ts) {
          if (!t0) t0 = ts;
          var el = ts - t0;
          var c = getCtx();

          /* Node glow per phase */
          var gh = 0, ga = 0;
          if (el < phase1T)
            gh = Math.sin(el/phase1T * Math.PI) * 0.8;
          else if (el >= phase2S && el < phase2S + phase2T)
            ga = Math.sin((el - phase2S)/phase2T * Math.PI) * 0.8;
          else if (el >= phase3S)
            gh = Math.sin((el - phase3S)/phase3T * Math.PI) * 0.4;

          drawScene(c, gh, ga);

          /* Phase 1: Human → AI  (plan) */
          drawParticles(c, P[0], el, 0, PLAN_N, STAGGER, FLOW_MS, HUMAN_C);
          /* Phase 2: AI → Report (execute) */
          drawParticles(c, P[1], el, phase2S, EXEC_N, STAGGER, FLOW_MS, AI_C);
          /* Phase 3: Report → Human (review) */
          drawParticles(c, P[2], el, phase3S, REV_N, STAGGER, FLOW_MS, REVIEW_C);

          c.globalAlpha = 1;

          /* Fire scheduled hints — accumulate in margins */
          while (hintFired < hintSchedule.length && el >= hintSchedule[hintFired][0]) {
            var hs = hintSchedule[hintFired];
            hintLog.push({ text: hs[1], side: hs[2], born: performance.now() });
            hintFired++;
            if (hintLog.length > 20) hintLog.splice(0, hintLog.length - 20);
          }

          if (el < totalT) {
            requestAnimationFrame(frame);
          } else {
            /* Update report version */
            reportVer = cycles;
            drawScene(getCtx(), 0, 0);
            ft.className = "panel-foot teal";
            ft.textContent = "Cycle #" + cycles + " \u2014 Report v" + reportVer +
              " produced. Loop complete.";
            if (!autoPlaying) btn.disabled = false;
            if (onDone) onDone();
          }
        }
        requestAnimationFrame(frame);
      }

      /* Auto-play 3 cycles on load */
      var AUTO_CYCLES = 3, AUTO_PAUSE = 900;
      function autoPlay(n) {
        autoPlaying = true;
        btn.textContent = "Playing\u2026";
        btn.disabled = true;
        runOneCycle(function () {
          if (n > 1) {
            setTimeout(function () { autoPlay(n - 1); }, AUTO_PAUSE);
          } else {
            autoPlaying = false;
            btn.disabled = false;
            btn.textContent = "Run Cycle";
          }
        });
      }
      setTimeout(function () { autoPlay(AUTO_CYCLES); }, 600);

      /* Manual trigger */
      btn.addEventListener("click", function () {
        if (!autoPlaying) runOneCycle(null);
      });
    })();

    /* ══════════════════════════════════════════════
       TOY 3: THE PROCESS — side-by-side, two loops
       ══════════════════════════════════════════════ */
    (function () {
      var stage = document.getElementById("process-stage");
      var btn = document.getElementById("process-btn");
      var ft = document.getElementById("ft-process");
      var running = false;

      var TEAL = "#0d9488";
      var GRAY = "#6b7280";
      var AMBER = "#92400e";
      var GREEN = "#16a34a";

      function sleep(ms) { return new Promise(function(r) { setTimeout(r, ms); }); }

      function typeText(el, text, charMs, done) {
        var i = 0;
        function next() {
          if (i < text.length) {
            el.textContent += text[i]; i++;
            setTimeout(next, charMs);
          } else if (done) { done(); }
        }
        next();
      }

      /* Highlight / dim a plan section */
      function glow(sec) { sec.style.background = "#f0fdfa"; sec.style.borderColor = "#99f6e4"; }
      function dim(sec) { sec.style.background = ""; sec.style.borderColor = "transparent"; }

      /* Small output card on right side */
      function card(title, color) {
        var w = document.createElement("div");
        w.style.cssText = "border:1px solid #e5e7eb;border-radius:8px;background:#fff;margin-bottom:8px;overflow:hidden;opacity:0;transition:opacity 0.4s";
        var h = document.createElement("div");
        h.style.cssText = "padding:6px 10px;border-bottom:1px solid #e5e7eb;display:flex;align-items:center;gap:6px";
        h.innerHTML = '<span style="width:6px;height:6px;border-radius:50%;background:' + color + '"></span><span style="font-size:10px;font-weight:600;letter-spacing:0.05em;text-transform:uppercase;color:' + color + '">' + title + '</span>';
        var b = document.createElement("div");
        b.style.cssText = "padding:8px 10px;white-space:pre-wrap;color:#374151;font-size:11px;line-height:1.5;min-height:16px";
        w.appendChild(h); w.appendChild(b);
        return { wrap: w, body: b };
      }

      /* Status tag */
      function tag(text, color) {
        var s = document.createElement("div");
        s.style.cssText = "font-size:10.5px;font-weight:600;letter-spacing:0.04em;color:" + color + ";opacity:0;transition:opacity 0.3s;margin-bottom:6px;padding:2px 0";
        s.textContent = text;
        return s;
      }

      /* Loop divider on right side */
      function loopHeader(text) {
        var d = document.createElement("div");
        d.style.cssText = "font-size:10px;font-weight:700;letter-spacing:0.08em;text-transform:uppercase;color:" + GRAY + ";margin:10px 0 6px;padding-bottom:4px;border-bottom:1px solid #e5e7eb;opacity:0;transition:opacity 0.3s";
        d.textContent = text;
        return d;
      }

      async function runProcess() {
        if (running) return;
        running = true;
        btn.disabled = true;
        btn.textContent = "Playing\u2026";
        stage.innerHTML = "";
        ft.className = "panel-foot neutral";
        ft.textContent = "Setting up\u2026";

        /* ── Side-by-side layout ── */
        var grid = document.createElement("div");
        grid.style.cssText = "display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:14px";
        var leftCol = document.createElement("div");
        var rightCol = document.createElement("div");
        grid.appendChild(leftCol);
        grid.appendChild(rightCol);
        stage.appendChild(grid);

        /* ── Build plan card on left ── */
        var planWrap = document.createElement("div");
        planWrap.style.cssText = "border:1px solid #e5e7eb;border-radius:8px;background:#fff;overflow:hidden;opacity:0;transition:opacity 0.4s";
        var planHead = document.createElement("div");
        planHead.style.cssText = "padding:7px 10px;border-bottom:1px solid #e5e7eb;display:flex;align-items:center;gap:6px";
        planHead.innerHTML = '<span style="width:7px;height:7px;border-radius:50%;background:' + TEAL + '"></span><span style="font-size:10.5px;font-weight:600;letter-spacing:0.06em;text-transform:uppercase;color:' + TEAL + '">main-plan.md</span>';
        var planBody = document.createElement("div");
        planBody.style.cssText = "padding:8px 10px;font-size:11px;line-height:1.5;color:#374151";

        /* Three plan sections */
        var secBefore = document.createElement("div");
        secBefore.style.cssText = "padding:5px 7px;border-radius:5px;margin-bottom:5px;transition:background 0.4s,border-color 0.4s;border:1px solid transparent;white-space:pre-line";
        secBefore.innerHTML = '<span style="font-weight:600">\u2705 Before Each Loop</span>\n<span style="color:#6b7280">- Version control \u2014 clean working tree\n- Script is idempotent\n- Raw data in 02-data/ unchanged</span>';

        var secLoop = document.createElement("div");
        secLoop.style.cssText = "padding:5px 7px;border-radius:5px;margin-bottom:5px;transition:background 0.4s,border-color 0.4s;border:1px solid transparent;white-space:pre-line";
        var loopLabel = document.createElement("span");
        loopLabel.style.fontWeight = "600";
        loopLabel.textContent = "\ud83d\udd01 Instruction Loop";
        var loopItems = document.createElement("div");
        loopItems.style.cssText = "color:#6b7280;white-space:pre-line";
        loopItems.textContent = "1. Load 02-data/raw/survey_responses.csv\n2. Filter to complete responses only\n3. Compute descriptive stats by group\n4. Run t-test (treatment vs control)\n5. Render summary \u2192 03-outputs/report.html";
        secLoop.appendChild(loopLabel);
        secLoop.appendChild(document.createTextNode("\n"));
        secLoop.appendChild(loopItems);

        var secAfter = document.createElement("div");
        secAfter.style.cssText = "padding:5px 7px;border-radius:5px;transition:background 0.4s,border-color 0.4s;border:1px solid transparent;white-space:pre-line";
        secAfter.innerHTML = '<span style="font-weight:600">\ud83d\udcdd After Each Loop</span>\n<span style="color:#6b7280">- Update activity log\n- Save version checkpoint</span>';

        planBody.appendChild(secBefore);
        planBody.appendChild(secLoop);
        planBody.appendChild(secAfter);
        planWrap.appendChild(planHead);
        planWrap.appendChild(planBody);
        leftCol.appendChild(planWrap);
        await sleep(300);
        planWrap.style.opacity = "1";
        await sleep(500);

        /* ════════════ LOOP 1 ════════════ */
        var lh1 = loopHeader("Loop 1");
        rightCol.appendChild(lh1);
        await sleep(80);
        lh1.style.opacity = "1";

        /* Before Each Loop */
        ft.textContent = "Loop 1 \u2014 Checking prerequisites\u2026";
        glow(secBefore);
        await sleep(700);
        dim(secBefore);

        /* Instruction Loop executes */
        ft.textContent = "Loop 1 \u2014 AI executing instructions\u2026";
        glow(secLoop);
        var s1 = tag("\u25b6 AI executing\u2026", GRAY);
        rightCol.appendChild(s1);
        await sleep(80);
        s1.style.opacity = "1";
        await sleep(500);

        var o1 = card("report.html", AMBER);
        rightCol.appendChild(o1.wrap);
        await sleep(80);
        o1.wrap.style.opacity = "1";
        var txt1 = "Survey Report\n\nN = 142 (89% complete)\n\nGroup        Mean   SD\nTreatment    74.2   8.1\nControl      71.8   7.9\n\nt(140) = 2.39, p = 0.018";
        await new Promise(function(r) { typeText(o1.body, txt1, 16, r); });
        s1.textContent = "\u2713 Output produced";
        s1.style.color = GREEN;
        await sleep(300);
        dim(secLoop);

        /* After Each Loop */
        ft.textContent = "Loop 1 \u2014 Saving checkpoint\u2026";
        glow(secAfter);
        await sleep(500);
        var c1 = tag("\u2713 Checkpoint saved", GREEN);
        rightCol.appendChild(c1);
        await sleep(80);
        c1.style.opacity = "1";
        await sleep(300);
        dim(secAfter);

        /* ════════════ REVISION ════════════ */
        await sleep(700);
        ft.textContent = "Author reviews output, adds a revision\u2026";
        var rev = document.createElement("div");
        rev.style.cssText = "margin-top:3px;padding:3px 6px;border-radius:4px;background:#fef3c7;color:#92400e;font-size:10px;font-weight:500;opacity:0;transition:opacity 0.5s";
        rev.textContent = "\u270e Revision: add 95% CI and effect size";
        secLoop.appendChild(rev);
        await sleep(150);
        rev.style.opacity = "1";
        await sleep(1000);

        /* ════════════ LOOP 2 ════════════ */
        var lh2 = loopHeader("Loop 2 \u2014 with revision");
        rightCol.appendChild(lh2);
        await sleep(80);
        lh2.style.opacity = "1";

        ft.textContent = "Loop 2 \u2014 Checking prerequisites\u2026";
        glow(secBefore);
        await sleep(600);
        dim(secBefore);

        ft.textContent = "Loop 2 \u2014 AI re-executing with revision\u2026";
        glow(secLoop);
        var s2 = tag("\u25b6 AI re-executing\u2026", GRAY);
        rightCol.appendChild(s2);
        await sleep(80);
        s2.style.opacity = "1";
        await sleep(500);

        var o2 = card("report.html (v2)", AMBER);
        rightCol.appendChild(o2.wrap);
        await sleep(80);
        o2.wrap.style.opacity = "1";
        var txt2 = "Survey Report v2\n\nN = 142 (89% complete)\n\nGroup        Mean   SD    95% CI\nTreatment    74.2   8.1   [72.1, 76.3]\nControl      71.8   7.9   [69.8, 73.8]\n\nt(140) = 2.39, p = 0.018\nCohen\u2019s d = 0.30 [0.05, 0.55]";
        await new Promise(function(r) { typeText(o2.body, txt2, 14, r); });
        s2.textContent = "\u2713 Output updated";
        s2.style.color = GREEN;
        await sleep(300);
        dim(secLoop);

        ft.textContent = "Loop 2 \u2014 Saving checkpoint\u2026";
        glow(secAfter);
        await sleep(500);
        var c2 = tag("\u2713 Checkpoint saved", GREEN);
        rightCol.appendChild(c2);
        await sleep(80);
        c2.style.opacity = "1";
        await sleep(300);
        dim(secAfter);

        /* ── Done ── */
        ft.className = "panel-foot teal";
        ft.textContent = "Two loops complete \u2014 same plan, refined output. Every checkpoint is saved and retraceable.";
        await sleep(600);
        running = false;
        btn.disabled = false;
        btn.textContent = "Replay";
      }

      /* Auto-play on load */
      setTimeout(runProcess, 1200);
      btn.addEventListener("click", function() { if (!running) runProcess(); });
    })();
    </script>
  </body>
</html>
